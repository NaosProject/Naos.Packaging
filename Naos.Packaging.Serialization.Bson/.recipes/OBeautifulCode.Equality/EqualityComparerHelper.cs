// --------------------------------------------------------------------------------------------------------------------
// <copyright file="EqualityComparerHelper.cs" company="OBeautifulCode">
//   Copyright (c) OBeautifulCode 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in OBeautifulCode.Equality.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.Equality.Recipes
{
    using System;
    using System.Collections.Generic;

    using OBeautifulCode.Type.Recipes;

    /// <summary>
    /// Helper methods related to <see cref="IEqualityComparer{T}"/>.
    /// </summary>
#if !OBeautifulCodeEqualityRecipesProject
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [System.CodeDom.Compiler.GeneratedCode("OBeautifulCode.Equality.Recipes", "See package version number")]
    internal
#else
    public
#endif
        static class EqualityComparerHelper
    {
        /// <summary>
        /// Gets the equality comparer to use for the specified type.
        /// </summary>
        /// <typeparam name="T">The type of the objects being compared.</typeparam>
        /// <param name="comparer">Optional comparer passed into the calling method.  Default is null, which instructs this method to determine the comparer.  If not null, then the specified comparer is returned.</param>
        /// <returns>
        /// The equality comparer to use for the specified type.
        /// </returns>
        public static IEqualityComparer<T> GetEqualityComparerToUse<T>(
            IEqualityComparer<T> comparer = null)
        {
            var type = typeof(T);

            IEqualityComparer<T> result;

            if (comparer != null)
            {
                result = comparer;
            }
            else if (type.IsClosedSystemDictionaryType())
            {
                // IDictionary is the only System dictionary type that doesn't implement IReadOnlyDictionary
                // which is why we have to special-case it here.
                var equalityComparerConstructorInfo = type.GetGenericTypeDefinition() == typeof(IDictionary<,>)
                    ? typeof(DictionaryEqualityComparer<,>).MakeGenericType(type.GenericTypeArguments).GetConstructor(new Type[0])
                    : typeof(ReadOnlyDictionaryEqualityComparer<,>).MakeGenericType(type.GenericTypeArguments).GetConstructor(new Type[0]);

                // ReSharper disable once PossibleNullReferenceException
                result = (IEqualityComparer<T>)equalityComparerConstructorInfo.Invoke(null);
            }
            else if (type.IsArray)
            {
                var constructorInfo = typeof(EnumerableEqualityComparer<>).MakeGenericType(type.GetElementType()).GetConstructor(new[] { typeof(EnumerableEqualityComparerStrategy) });

                // ReSharper disable once PossibleNullReferenceException
                result = (IEqualityComparer<T>)constructorInfo.Invoke(new object[] { EnumerableEqualityComparerStrategy.SequenceEqual });
            }
            else if (type.IsClosedSystemCollectionType())
            {
                var constructorInfo = typeof(EnumerableEqualityComparer<>).MakeGenericType(type.GenericTypeArguments).GetConstructor(new[] { typeof(EnumerableEqualityComparerStrategy) });

                var enumerableEqualityComparerStrategy = type.IsClosedSystemOrderedCollectionType() ? EnumerableEqualityComparerStrategy.SequenceEqual : EnumerableEqualityComparerStrategy.UnorderedEqual;

                // ReSharper disable once PossibleNullReferenceException
                result = (IEqualityComparer<T>)constructorInfo.Invoke(new object[] { enumerableEqualityComparerStrategy });
            }
            else if (type.IsClosedSystemEnumerableType())
            {
                var constructorInfo = typeof(EnumerableEqualityComparer<>).MakeGenericType(type.GenericTypeArguments).GetConstructor(new[] { typeof(EnumerableEqualityComparerStrategy) });

                // ReSharper disable once PossibleNullReferenceException
                result = (IEqualityComparer<T>)constructorInfo.Invoke(new object[] { EnumerableEqualityComparerStrategy.UnorderedEqual });
            }
            else if (type == typeof(DateTime))
            {
                result = (IEqualityComparer<T>)new DateTimeEqualityComparer();
            }
            else
            {
                result = EqualityComparer<T>.Default;
            }

            return result;
        }
    }
}