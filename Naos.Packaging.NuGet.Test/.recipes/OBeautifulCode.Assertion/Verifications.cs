// --------------------------------------------------------------------------------------------------------------------
// <copyright file="Verifications.cs" company="OBeautifulCode">
//   Copyright (c) OBeautifulCode 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in OBeautifulCode.Assertion.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.Assertion.Recipes
{
    using global::System;
    using global::System.Collections;
    using global::System.Collections.Generic;
    using global::System.Globalization;
    using global::System.Linq;
    using global::System.Text.RegularExpressions;

    using OBeautifulCode.Type.Recipes;

    using static global::System.FormattableString;

    /// <summary>
    /// Contains all verifications that can be applied to an <see cref="AssertionTracker"/>.
    /// </summary>
#if !OBeautifulCodeAssertionSolution
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [global::System.CodeDom.Compiler.GeneratedCode("OBeautifulCode.Assertion.Recipes", "See package version number")]
    internal
#else
    public
#endif
    static partial class Verifications
    {
        /// <summary>
        /// Verifies that the reference type or nullable subject is null.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeNull(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeNullInternal,
                Name = nameof(BeNull),
                TypeValidations = MustBeAssignableToNullTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the reference type or nullable subject is not null.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeNull(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeNullInternal,
                Name = nameof(NotBeNull),
                TypeValidations = MustBeAssignableToNullTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the bool or bool? subject is true.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeTrue(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeTrueInternal,
                Name = nameof(BeTrue),
                TypeValidations = MustBeBooleanOrNullableBooleanTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the bool or bool? subject is not true.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeTrue(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeTrueInternal,
                Name = nameof(NotBeTrue),
                TypeValidations = MustBeBooleanOrNullableBooleanTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the bool or bool? subject is false.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeFalse(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeFalseInternal,
                Name = nameof(BeFalse),
                TypeValidations = MustBeBooleanOrNullableBooleanTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the bool? or bool? subject is not false.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeFalse(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeFalseInternal,
                Name = nameof(NotBeFalse),
                TypeValidations = MustBeBooleanOrNullableBooleanTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the string subject is neither null nor whitespace.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeNullNorWhiteSpace(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeNullNorWhiteSpaceInternal,
                Name = nameof(NotBeNullNorWhiteSpace),
                TypeValidations = MustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the string subject is null or not white space.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeNullOrNotWhiteSpace(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeNullOrNotWhiteSpaceInternal,
                Name = nameof(BeNullOrNotWhiteSpace),
                TypeValidations = MustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the guid or guid? subject is empty.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeEmptyGuid(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeEmptyGuidInternal,
                Name = nameof(BeEmptyGuid),
                TypeValidations = MustBeGuidOrNullableGuidTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the guid or guid? subject is not empty.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeEmptyGuid(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeEmptyGuidInternal,
                Name = nameof(NotBeEmptyGuid),
                TypeValidations = MustBeGuidOrNullableGuidTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the string subject is empty.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeEmptyString(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeEmptyStringInternal,
                Name = nameof(BeEmptyString),
                TypeValidations = MustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the string subject is not empty.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeEmptyString(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeEmptyStringInternal,
                Name = nameof(NotBeEmptyString),
                TypeValidations = MustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject is empty.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeEmptyEnumerable(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeEmptyEnumerableInternal,
                Name = nameof(BeEmptyEnumerable),
                TypeValidations = MustBeEnumerableTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject is not empty.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeEmptyEnumerable(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeEmptyEnumerableInternal,
                Name = nameof(NotBeEmptyEnumerable),
                TypeValidations = MustBeEnumerableTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IDictionary, IDictionary{TKey,TValue}, or IReadOnlyDictionary{TKey,TValue} subject is empty.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeEmptyDictionary(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeEmptyDictionaryInternal,
                Name = nameof(BeEmptyDictionary),
                TypeValidations = MustBeDictionaryTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IDictionary, IDictionary{TKey,TValue}, or IReadOnlyDictionary{TKey,TValue} subject is not empty.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeEmptyDictionary(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeEmptyDictionaryInternal,
                Name = nameof(NotBeEmptyDictionary),
                TypeValidations = MustBeDictionaryTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject contains at least one null element.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker ContainSomeNullElements(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = ContainSomeNullElementsInternal,
                Name = nameof(ContainSomeNullElements),
                TypeValidations = MustBeEnumerableWhoseElementTypeCanBeAssignedToNullValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject does not contain any null elements.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotContainAnyNullElements(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotContainAnyNullElementsInternal,
                Name = nameof(NotContainAnyNullElements),
                TypeValidations = MustBeEnumerableWhoseElementTypeCanBeAssignedToNullValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject does not contain any null elements, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotContainAnyNullElementsWhenNotNull(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotContainAnyNullElementsWhenNotNullInternal,
                Name = nameof(NotContainAnyNullElementsWhenNotNull),
                TypeValidations = MustBeEnumerableWhoseElementTypeCanBeAssignedToNullValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IDictionary, IDictionary{TKey,TValue}, or IReadOnlyDictionary{TKey,TValue} subject contains at least one null value.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker ContainSomeKeyValuePairsWithNullValue(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = ContainSomeKeyValuePairsWithNullValueInternal,
                Name = nameof(ContainSomeKeyValuePairsWithNullValue),
                TypeValidations = MustBeDictionaryWhoseValueTypeCanBeAssignedToNullValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IDictionary, IDictionary{TKey,TValue}, or IReadOnlyDictionary{TKey,TValue} subject does not contain any null values.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotContainAnyKeyValuePairsWithNullValue(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotContainAnyKeyValuePairsWithNullValueInternal,
                Name = nameof(NotContainAnyKeyValuePairsWithNullValue),
                TypeValidations = MustBeDictionaryWhoseValueTypeCanBeAssignedToNullValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IDictionary, IDictionary{TKey,TValue}, or IReadOnlyDictionary{TKey,TValue} subject contains a specified key.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="keyToSearchFor">The key to search for.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker ContainKey<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T keyToSearchFor,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (keyToSearchFor == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(ContainKey), nameof(keyToSearchFor));

                WorkflowExtensions.ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = ContainKeyInternal,
                Name = nameof(ContainKey),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(keyToSearchFor),
                        Value = keyToSearchFor,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = DictionaryKeyContainmentTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IDictionary, IDictionary{TKey,TValue}, or IReadOnlyDictionary{TKey,TValue} subject does not contain a specified key.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="keyToSearchFor">The key to search for.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotContainKey<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T keyToSearchFor,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (keyToSearchFor == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(NotContainKey), nameof(keyToSearchFor));

                WorkflowExtensions.ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotContainKeyInternal,
                Name = nameof(NotContainKey),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(keyToSearchFor),
                        Value = keyToSearchFor,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = DictionaryKeyContainmentTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IDictionary, IDictionary{TKey,TValue}, or IReadOnlyDictionary{TKey,TValue} subject contains a specified key, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="keyToSearchFor">The key to search for.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker ContainKeyWhenNotNull<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T keyToSearchFor,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (keyToSearchFor == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(ContainKeyWhenNotNull), nameof(keyToSearchFor));

                WorkflowExtensions.ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = ContainKeyWhenNotNullInternal,
                Name = nameof(ContainKeyWhenNotNull),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(keyToSearchFor),
                        Value = keyToSearchFor,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = DictionaryKeyContainmentTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IDictionary, IDictionary{TKey,TValue}, or IReadOnlyDictionary{TKey,TValue} subject does not contain a specified key, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="keyToSearchFor">The key to search for.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotContainKeyWhenNotNull<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T keyToSearchFor,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (keyToSearchFor == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(NotContainKeyWhenNotNull), nameof(keyToSearchFor));

                WorkflowExtensions.ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotContainKeyWhenNotNullInternal,
                Name = nameof(NotContainKeyWhenNotNull),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(keyToSearchFor),
                        Value = keyToSearchFor,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = DictionaryKeyContainmentTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject is not null nor empty.
        /// </summary>
        /// <remarks>
        /// This verification is effectively the same as <see cref="NotBeEmptyEnumerable"/> and exists for completeness.
        /// </remarks>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeNullNorEmptyEnumerable(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeEmptyEnumerableInternal,
                Name = nameof(NotBeNullNorEmptyEnumerable),
                TypeValidations = MustBeEnumerableTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject is not null nor empty nor contains any null elements.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeNullNorEmptyEnumerableNorContainAnyNulls(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verificationName = nameof(NotBeNullNorEmptyEnumerableNorContainAnyNulls);

            var verification1 = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeEmptyEnumerableInternal,
                Name = verificationName,
                TypeValidations = MustBeEnumerableWhoseElementTypeCanBeAssignedToNullValidations,
                Data = data,
            };

            var verification2 = new Verification
            {
                Because = because,
                Handler = NotContainAnyNullElementsInternal,
                Name = verificationName,
                TypeValidations = null,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification1);
            assertionTracker.ExecuteVerification(verification2);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IDictionary, IDictionary{TKey,TValue}, or IReadOnlyDictionary{TKey,TValue} subject is not null nor empty nor contains any null values.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeNullNorEmptyDictionaryNorContainAnyNullValues(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verificationName = nameof(NotBeNullNorEmptyDictionaryNorContainAnyNullValues);

            var verification1 = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeEmptyDictionaryInternal,
                Name = verificationName,
                TypeValidations = MustBeDictionaryWhoseValueTypeCanBeAssignedToNullValidations,
                Data = data,
            };

            var verification2 = new Verification
            {
                Because = because,
                Handler = NotContainAnyKeyValuePairsWithNullValueInternal,
                Name = verificationName,
                TypeValidations = null,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification1);
            assertionTracker.ExecuteVerification(verification2);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IDictionary, IDictionary{TKey,TValue}, or IReadOnlyDictionary{TKey,TValue} subject is not null nor empty.
        /// </summary>
        /// <remarks>
        /// This verification is effectively the same as <see cref="NotBeEmptyDictionary"/> and exists for completeness.
        /// </remarks>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeNullNorEmptyDictionary(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeEmptyDictionaryInternal,
                Name = nameof(NotBeNullNorEmptyDictionary),
                TypeValidations = MustBeDictionaryTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is equal to default(T).
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeDefault(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeDefaultInternal,
                Name = nameof(BeDefault),
                TypeValidations = null,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is not equal to default(T).
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeDefault(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeDefaultInternal,
                Name = nameof(NotBeDefault),
                TypeValidations = null,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IComparable or IComparable{T} subject is less than some specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeLessThan<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeLessThanInternal,
                Name = nameof(BeLessThan),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = InequalityTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IComparable or IComparable{T} subject is not less than some specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeLessThan<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeLessThanInternal,
                Name = nameof(NotBeLessThan),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = InequalityTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IComparable or IComparable{T} subject is greater than some specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeGreaterThan<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeGreaterThanInternal,
                Name = nameof(BeGreaterThan),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = InequalityTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IComparable or IComparable{T} subject is not greater than some specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeGreaterThan<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeGreaterThanInternal,
                Name = nameof(NotBeGreaterThan),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = InequalityTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IComparable or IComparable{T} subject is less than or equal to some specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeLessThanOrEqualTo<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeLessThanOrEqualToInternal,
                Name = nameof(BeLessThanOrEqualTo),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = InequalityTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IComparable or IComparable{T} subject is not less or equal to some specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeLessThanOrEqualTo<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeLessThanOrEqualToInternal,
                Name = nameof(NotBeLessThanOrEqualTo),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = InequalityTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IComparable or IComparable{T} subject is greater than or equal to some specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeGreaterThanOrEqualTo<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeGreaterThanOrEqualToInternal,
                Name = nameof(BeGreaterThanOrEqualTo),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = InequalityTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IComparable or IComparable{T} subject is not greater than or equal to some specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeGreaterThanOrEqualTo<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeGreaterThanOrEqualToInternal,
                Name = nameof(NotBeGreaterThanOrEqualTo),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = InequalityTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is equal to some specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeEqualTo<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeEqualToInternal,
                Name = nameof(BeEqualTo),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = EqualsTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is not equal to some specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeEqualTo<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeEqualToInternal,
                Name = nameof(NotBeEqualTo),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = EqualsTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is equal to some specified value, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeEqualToWhenNotNull<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeEqualToWhenNotNullInternal,
                Name = nameof(BeEqualToWhenNotNull),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = EqualsTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is not equal to some specified value, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeEqualToWhenNotNull<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeEqualToWhenNotNullInternal,
                Name = nameof(NotBeEqualToWhenNotNull),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = EqualsTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is equal to any of the specified values.
        /// </summary>
        /// <typeparam name="T">The type of the comparison values.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValues">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeEqualToAnyOf<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            IReadOnlyCollection<T> comparisonValues,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (comparisonValues == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(BeEqualToAnyOf), nameof(comparisonValues));

                WorkflowExtensions.ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeEqualToAnyOfInternal,
                Name = nameof(BeEqualToAnyOf),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValues),
                        Value = comparisonValues,
                        ParameterType = typeof(IReadOnlyCollection<T>),
                        ValueToStringFunc = () => comparisonValues.BuildReadOnlyCollectionVerificationParameterToString(BuildReadOnlyCollectionVerificationParameterToStringMaxItems),
                    },
                },
                TypeValidations = EqualsAnyOfTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is not equal to any of the specified values.
        /// </summary>
        /// <typeparam name="T">The type of the comparison values.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValues">The values to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeEqualToAnyOf<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            IReadOnlyCollection<T> comparisonValues,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (comparisonValues == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(NotBeEqualToAnyOf), nameof(comparisonValues));

                WorkflowExtensions.ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeEqualToAnyOfInternal,
                Name = nameof(NotBeEqualToAnyOf),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValues),
                        Value = comparisonValues,
                        ParameterType = typeof(IReadOnlyCollection<T>),
                        ValueToStringFunc = () => comparisonValues.BuildReadOnlyCollectionVerificationParameterToString(BuildReadOnlyCollectionVerificationParameterToStringMaxItems),
                    },
                },
                TypeValidations = EqualsAnyOfTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is equal to any of the specified values, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <typeparam name="T">The type of the comparison values.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValues">The values to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeEqualToAnyOfWhenNotNull<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            IReadOnlyCollection<T> comparisonValues,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (comparisonValues == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(BeEqualToAnyOfWhenNotNull), nameof(comparisonValues));

                WorkflowExtensions.ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeEqualToAnyOfWhenNotNullInternal,
                Name = nameof(BeEqualToAnyOfWhenNotNull),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValues),
                        Value = comparisonValues,
                        ParameterType = typeof(IReadOnlyCollection<T>),
                        ValueToStringFunc = () => comparisonValues.BuildReadOnlyCollectionVerificationParameterToString(BuildReadOnlyCollectionVerificationParameterToStringMaxItems),
                    },
                },
                TypeValidations = EqualsAnyOfTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is not equal to any of the specified values, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <typeparam name="T">The type of the comparison values.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValues">The values to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeEqualToAnyOfWhenNotNull<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            IReadOnlyCollection<T> comparisonValues,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (comparisonValues == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(NotBeEqualToAnyOfWhenNotNull), nameof(comparisonValues));

                WorkflowExtensions.ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeEqualToAnyOfWhenNotNullInternal,
                Name = nameof(NotBeEqualToAnyOfWhenNotNull),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValues),
                        Value = comparisonValues,
                        ParameterType = typeof(IReadOnlyCollection<T>),
                        ValueToStringFunc = () => comparisonValues.BuildReadOnlyCollectionVerificationParameterToString(BuildReadOnlyCollectionVerificationParameterToStringMaxItems),
                    },
                },
                TypeValidations = EqualsAnyOfTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IComparable or IComparable{T} subject is within a specified range.
        /// </summary>
        /// <typeparam name="T">The type of the comparison values.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="minimum">The minimum comparison value (start of the range).</param>
        /// <param name="maximum">The maximum comparison value (end of the range).</param>
        /// <param name="endpointDelineation">Optional instruction on whether the range is inclusive or exclusive of the endpoints.  Default is to include both the <paramref name="minimum"/> and <paramref name="maximum"/> in the range.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeInRange<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T minimum,
            T maximum,
            Range endpointDelineation = Range.IncludesMinimumAndMaximum,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (endpointDelineation != Range.IncludesMinimumAndMaximum)
            {
                throw new NotImplementedException("This endpoint delineation is not yet implemented: " + endpointDelineation);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeInRangeInternal,
                Name = nameof(BeInRange),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(minimum),
                        Value = minimum,
                        ParameterType = typeof(T),
                    },
                    new VerificationParameter
                    {
                        Name = nameof(maximum),
                        Value = maximum,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = InequalityTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IComparable or IComparable{T} subject is not within a specified range.
        /// </summary>
        /// <typeparam name="T">The type of the comparison values.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="minimum">The minimum comparison value (start of the range).</param>
        /// <param name="maximum">The maximum comparison value (end of the range).</param>
        /// <param name="endpointDelineation">Optional instruction on whether the range is inclusive or exclusive of the endpoints.  Default is to include both the <paramref name="minimum"/> and <paramref name="maximum"/> in the range.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeInRange<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T minimum,
            T maximum,
            Range endpointDelineation = Range.IncludesMinimumAndMaximum,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (endpointDelineation != Range.IncludesMinimumAndMaximum)
            {
                throw new NotImplementedException("This endpoint delineation is not yet implemented: " + endpointDelineation + ".");
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeInRangeInternal,
                Name = nameof(NotBeInRange),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(minimum),
                        Value = minimum,
                        ParameterType = typeof(T),
                    },
                    new VerificationParameter
                    {
                        Name = nameof(maximum),
                        Value = maximum,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = InequalityTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject contains a specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="itemToSearchFor">The item to search for.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker ContainElement<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T itemToSearchFor,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = ContainElementInternal,
                Name = nameof(ContainElement),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(itemToSearchFor),
                        Value = itemToSearchFor,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = ContainmentTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject does not contain a specified value.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="itemToSearchFor">The item to search for.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotContainElement<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T itemToSearchFor,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotContainElementInternal,
                Name = nameof(NotContainElement),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(itemToSearchFor),
                        Value = itemToSearchFor,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = ContainmentTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject contains a specified value, when not null.
        /// If null, no exception is thrown
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="itemToSearchFor">The item to search for.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker ContainElementWhenNotNull<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T itemToSearchFor,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = ContainElementWhenNotNullInternal,
                Name = nameof(ContainElementWhenNotNull),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(itemToSearchFor),
                        Value = itemToSearchFor,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = ContainmentTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject does not contain a specified value, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="itemToSearchFor">The item to search for.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotContainElementWhenNotNull<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T itemToSearchFor,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotContainElementWhenNotNullInternal,
                Name = nameof(NotContainElementWhenNotNull),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(itemToSearchFor),
                        Value = itemToSearchFor,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = ContainmentTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject contains only distinct elements
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker ContainOnlyDistinctElements(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = ContainOnlyDistinctElementsInternal,
                Name = nameof(ContainOnlyDistinctElements),
                TypeValidations = MustBeEnumerableTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject contains only distinct elements, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker ContainOnlyDistinctElementsWhenNotNull(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = ContainOnlyDistinctElementsWhenNotNullInternal,
                Name = nameof(ContainOnlyDistinctElementsWhenNotNull),
                TypeValidations = MustBeEnumerableTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the string subject is alphabetic.
        /// </summary>
        /// <remarks>
        /// An empty string is considered to be alphabetic.
        /// </remarks>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="otherAllowedCharacters">Optional set of other characters that are allowed (e.g. '-').  Default is none (strict definition of alphabetic).</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeAlphabetic(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            IReadOnlyCollection<char> otherAllowedCharacters = null,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeAlphabeticInternal,
                Name = nameof(BeAlphabetic),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(otherAllowedCharacters),
                        Value = otherAllowedCharacters,
                        ParameterType = typeof(IReadOnlyCollection<char>),
                        ValueToStringFunc = () =>
                        {
                            string result;
                            if (otherAllowedCharacters == null)
                            {
                                result = NullValueToString;
                            }
                            else if (otherAllowedCharacters.Count == 0)
                            {
                                result = EmptyEnumerableToString;
                            }
                            else
                            {
                                var otherAllowedCharactersToString = otherAllowedCharacters.Select(_ => Invariant($"'{_}'")).ToArray();

                                result = Invariant($"[{string.Join(", ", otherAllowedCharactersToString)}]");
                            }

                            return result;
                        },
                    },
                },
                TypeValidations = MustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the string subject is alphanumeric.
        /// </summary>
        /// <remarks>
        /// An empty string is considered to be alphanumeric.
        /// </remarks>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="otherAllowedCharacters">Optional set of other characters that are allowed (e.g. '-').  Default is none (strict definition of alphanumeric).</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeAlphanumeric(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            IReadOnlyCollection<char> otherAllowedCharacters = null,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeAlphanumericInternal,
                Name = nameof(BeAlphanumeric),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(otherAllowedCharacters),
                        Value = otherAllowedCharacters,
                        ParameterType = typeof(IReadOnlyCollection<char>),
                        ValueToStringFunc = () =>
                        {
                            string result;
                            if (otherAllowedCharacters == null)
                            {
                                result = NullValueToString;
                            }
                            else if (otherAllowedCharacters.Count == 0)
                            {
                                result = EmptyEnumerableToString;
                            }
                            else
                            {
                                var otherAllowedCharactersToString = otherAllowedCharacters.Select(_ => Invariant($"'{_}'")).ToArray();

                                result = Invariant($"[{string.Join(", ", otherAllowedCharactersToString)}]");
                            }

                            return result;
                        },
                    },
                },
                TypeValidations = MustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the string subject is in the ASCII printable set (ASCII 32-126).
        /// </summary>
        /// <remarks>
        /// An empty string is considered to be printable.
        /// </remarks>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="treatNewLineAsPrintable">Optional value indicating whether to treat newline as printable.  Default value is false; newline will not be treated as printable.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeAsciiPrintable(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            bool treatNewLineAsPrintable = false,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeAsciiPrintableInternal,
                Name = nameof(BeAsciiPrintable),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(treatNewLineAsPrintable),
                        Value = treatNewLineAsPrintable,
                        ParameterType = typeof(bool),
                    },
                },
                TypeValidations = MustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that a regex finds a match in the string subject.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="regex">The regex to use.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeMatchedByRegex(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            Regex regex,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (regex == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(BeMatchedByRegex), nameof(regex));

                WorkflowExtensions.ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeMatchedByRegexInternal,
                Name = nameof(BeMatchedByRegex),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(regex),
                        Value = regex,
                        ParameterType = typeof(Regex),

                        // ReSharper disable once PossibleNullReferenceException
                        ValueToStringFunc = regex.ToString,
                    },
                },
                TypeValidations = MustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that a regex does not find a match in the string subject.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="regex">The regex to use.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeMatchedByRegex(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            Regex regex,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (regex == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(NotBeMatchedByRegex), nameof(regex));

                WorkflowExtensions.ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeMatchedByRegexInternal,
                Name = nameof(NotBeMatchedByRegex),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(regex),
                        Value = regex,
                        ParameterType = typeof(Regex),

                        // ReSharper disable once PossibleNullReferenceException
                        ValueToStringFunc = regex.ToString,
                    },
                },
                TypeValidations = MustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the string subject starts with a specified string.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The string value to find.</param>
        /// <param name="comparisonType">Optional value that determines how the string subject and <paramref name="comparisonValue"/> are compared.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker StartWith(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string comparisonValue,
            StringComparison? comparisonType = null,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (comparisonValue == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(StartWith), nameof(comparisonValue));

                WorkflowExtensions.ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = StartWithInternal,
                Name = nameof(StartWith),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(string),
                    },
                    new VerificationParameter
                    {
                        Name = nameof(comparisonType),
                        Value = comparisonType,
                        ParameterType = typeof(StringComparison),
                    },
                },
                TypeValidations = MustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the string subject does not starts with a specified string.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The string value to find.</param>
        /// <param name="comparisonType">Optional value that determines how the string subject and <paramref name="comparisonValue"/> are compared.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotStartWith(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string comparisonValue,
            StringComparison? comparisonType = null,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (comparisonValue == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(NotStartWith), nameof(comparisonValue));

                WorkflowExtensions.ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotStartWithInternal,
                Name = nameof(NotStartWith),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(string),
                    },
                    new VerificationParameter
                    {
                        Name = nameof(comparisonType),
                        Value = comparisonType,
                        ParameterType = typeof(StringComparison),
                    },
                },
                TypeValidations = MustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the reference-type subject is the exact same object as the specified comparison value.
        /// </summary>
        /// <typeparam name="T">The type of subject.</typeparam>
        /// <remarks>
        /// Value types are boxed as object and thus they are never the same reference.
        /// This verification will throw for value types.
        /// </remarks>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeSameReferenceAs<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeSameReferenceAsInternal,
                Name = nameof(BeSameReferenceAs),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = BeSameReferenceAsTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the reference-type subject is not the exact same object as the specified comparison value.
        /// </summary>
        /// <remarks>
        /// Value types are boxed as object and thus they are never the same reference.
        /// This verification will throw for value types.
        /// </remarks>
        /// <typeparam name="T">The type of the comparison value.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The value to compare the subject value to.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeSameReferenceAs<T>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            T comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeSameReferenceAsInternal,
                Name = nameof(NotBeSameReferenceAs),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(T),
                    },
                },
                TypeValidations = BeSameReferenceAsTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the string subject contains a specified string.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The string value to find.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker ContainString(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (comparisonValue == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(ContainString), nameof(comparisonValue));

                WorkflowExtensions.ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = ContainStringInternal,
                Name = nameof(ContainString),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(string),
                    },
                },
                TypeValidations = MustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the string subject does not contain a specified string.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="comparisonValue">The string value to find.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotContainString(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string comparisonValue,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (comparisonValue == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(NotContainString), nameof(comparisonValue));

                WorkflowExtensions.ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotContainStringInternal,
                Name = nameof(NotContainString),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(comparisonValue),
                        Value = comparisonValue,
                        ParameterType = typeof(string),
                    },
                },
                TypeValidations = MustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject has a specified number of elements.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="expectedCount">The expected number of elements.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker HaveCount(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            int expectedCount,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (expectedCount < 0)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsLessThanZeroErrorMessage, nameof(HaveCount), nameof(expectedCount), expectedCount);

                WorkflowExtensions.ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = HaveCountInternal,
                Name = nameof(HaveCount),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(expectedCount),
                        Value = expectedCount,
                        ParameterType = typeof(int),
                    },
                },
                TypeValidations = MustBeEnumerableTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the IEnumerable subject does not has a specified number of elements.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="unexpectedCount">The unexpected number of elements.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotHaveCount(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            int unexpectedCount,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (unexpectedCount < 0)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsLessThanZeroErrorMessage, nameof(NotHaveCount), nameof(unexpectedCount), unexpectedCount);

                WorkflowExtensions.ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotHaveCountInternal,
                Name = nameof(NotHaveCount),
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(unexpectedCount),
                        Value = unexpectedCount,
                        ParameterType = typeof(int),
                    },
                },
                TypeValidations = MustBeEnumerableTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is of the specified type.
        /// </summary>
        /// <typeparam name="TExpected">The expected type.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeOfType<TExpected>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeOfTypeInternal,
                Name = nameof(BeOfType),
                Data = data,
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(TExpected),
                        Value = typeof(TExpected),
                        ParameterType = typeof(Type),
                        ValueToStringFunc = () => "'" + typeof(TExpected).ToStringReadable() + "'",
                    },
                },
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is not of the specified type.
        /// </summary>
        /// <typeparam name="TUnexpected">The unexpected type.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeOfType<TUnexpected>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeOfTypeInternal,
                Name = nameof(NotBeOfType),
                Data = data,
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(TUnexpected),
                        Value = typeof(TUnexpected),
                        ParameterType = typeof(Type),
                        ValueToStringFunc = () => "'" + typeof(TUnexpected).ToStringReadable() + "'",
                    },
                },
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is of the specified type.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="expectedType">The expected type.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeOfType(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            Type expectedType,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (expectedType == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(BeOfType), nameof(expectedType));

                WorkflowExtensions.ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeOfTypeInternal,
                Name = nameof(BeOfType),
                Data = data,
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(expectedType),
                        Value = expectedType,
                        ParameterType = typeof(Type),
                        ValueToStringFunc = () => "'" + expectedType.ToStringReadable() + "'",
                    },
                },
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is not of the specified type.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="unexpectedType">The unexpected type.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeOfType(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            Type unexpectedType,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (unexpectedType == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(NotBeOfType), nameof(unexpectedType));

                WorkflowExtensions.ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeOfTypeInternal,
                Name = nameof(NotBeOfType),
                Data = data,
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(unexpectedType),
                        Value = unexpectedType,
                        ParameterType = typeof(Type),
                        ValueToStringFunc = () => "'" + unexpectedType.ToStringReadable() + "'",
                    },
                },
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is assignable to the specified type.
        /// </summary>
        /// <typeparam name="TAssignable">The the assignable type.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeAssignableToType<TAssignable>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeAssignableToTypeInternal,
                Name = nameof(BeAssignableToType),
                Data = data,
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(TAssignable),
                        Value = typeof(TAssignable),
                        ParameterType = typeof(Type),
                        ValueToStringFunc = () => "'" + typeof(TAssignable).ToStringReadable() + "'",
                    },
                },
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is not assignable to the specified type.
        /// </summary>
        /// <typeparam name="TUnassignable">The unassignable type.</typeparam>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeAssignableToType<TUnassignable>(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeAssignableToTypeInternal,
                Name = nameof(NotBeAssignableToType),
                Data = data,
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(TUnassignable),
                        Value = typeof(TUnassignable),
                        ParameterType = typeof(Type),
                        ValueToStringFunc = () => "'" + typeof(TUnassignable).ToStringReadable() + "'",
                    },
                },
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is assignable to the specified type.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="assignableType">The assignable type.</param>
        /// <param name="treatUnboundGenericAsAssignableTo">Treats an unbound generic as a type that can be assigned to (e.g. IsAssignableTo(List&lt;int&gt;, List&lt;&gt;)).</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeAssignableToType(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            Type assignableType,
            bool treatUnboundGenericAsAssignableTo = false,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (assignableType == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(BeAssignableToType), nameof(assignableType));

                WorkflowExtensions.ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeAssignableToTypeInternal,
                Name = nameof(BeAssignableToType),
                Data = data,
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(assignableType),
                        Value = assignableType,
                        ParameterType = typeof(Type),
                        ValueToStringFunc = () => "'" + assignableType.ToStringReadable() + "'",
                    },
                    new VerificationParameter
                    {
                        Name = nameof(treatUnboundGenericAsAssignableTo),
                        Value = treatUnboundGenericAsAssignableTo,
                        ParameterType = typeof(bool),
                    },
                },
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the subject is not assignable to the specified type.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="unassignableType">The unassignable type.</param>
        /// <param name="treatUnboundGenericAsAssignableTo">Treats an unbound generic as a type that can be assigned to (e.g. IsAssignableTo(List&lt;int&gt;, List&lt;&gt;)).</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeAssignableToType(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            Type unassignableType,
            bool treatUnboundGenericAsAssignableTo = false,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            if (unassignableType == null)
            {
                var errorMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterIsNullErrorMessage, nameof(NotBeAssignableToType), nameof(unassignableType));

                WorkflowExtensions.ThrowImproperUseOfFramework(errorMessage);
            }

            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeAssignableToTypeInternal,
                Name = nameof(NotBeAssignableToType),
                Data = data,
                VerificationParameters = new[]
                {
                    new VerificationParameter
                    {
                        Name = nameof(unassignableType),
                        Value = unassignableType,
                        ParameterType = typeof(Type),
                        ValueToStringFunc = () => "'" + unassignableType.ToStringReadable() + "'",
                    },
                    new VerificationParameter
                    {
                        Name = nameof(treatUnboundGenericAsAssignableTo),
                        Value = treatUnboundGenericAsAssignableTo,
                        ParameterType = typeof(bool),
                    },
                },
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the string subject is in valid email format.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeValidEmailAddress(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeValidEmailAddressInternal,
                Name = nameof(BeValidEmailAddress),
                TypeValidations = MustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the string subject is not in valid email format.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker NotBeValidEmailAddress(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = NotBeValidEmailAddressInternal,
                Name = nameof(NotBeValidEmailAddress),
                TypeValidations = MustBeStringTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the DateTime or DateTime? subject has <see cref="DateTimeKind.Utc"/>.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeUtcDateTime(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeUtcDateTimeInternal,
                Name = nameof(BeUtcDateTime),
                TypeValidations = MustBeDateTimeOrNullableDateTimeTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Verifies that the DateTime? subject has <see cref="DateTimeKind.Utc"/>, when not null.
        /// If null, no exception is thrown.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeUtcDateTimeWhenNotNull(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = BeUtcDateTimeWhenNotNullInternal,
                Name = nameof(BeUtcDateTimeWhenNotNull),
                TypeValidations = MustBeNullableDateTimeTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }

        /// <summary>
        /// Always throws.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="because">Optional rationale for the verification, used in the exception message if the subject fails this verification.  The default is use the framework-generated exception message as-is.</param>
        /// <param name="applyBecause">Optional value that determines how to apply the <paramref name="because"/>, when specified.  The default is to prefix the framework-generated exception message with <paramref name="because"/>.</param>
        /// <param name="data">Optional collection of key/value pairs that provide additional user-defined information that is added to the exception's <see cref="Exception.Data"/> property, if thrown.  The default is no user-defined information.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker BeOfTypeThatDoesNotExist(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            string because = null,
            ApplyBecause applyBecause = ApplyBecause.PrefixedToDefaultMessage,
            IDictionary data = null)
        {
            var verification = new Verification
            {
                Because = because,
                ApplyBecause = applyBecause,
                Handler = null,
                Name = nameof(BeOfTypeThatDoesNotExist),
                TypeValidations = AlwaysThrowTypeValidations,
                Data = data,
            };

            assertionTracker.ExecuteVerification(verification);

            return assertionTracker;
        }
    }
}
