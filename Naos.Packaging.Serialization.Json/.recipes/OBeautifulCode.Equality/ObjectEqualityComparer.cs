// --------------------------------------------------------------------------------------------------------------------
// <copyright file="ObjectEqualityComparer.cs" company="OBeautifulCode">
//   Copyright (c) OBeautifulCode 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in OBeautifulCode.Equality.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.Equality.Recipes
{
    using global::System;
    using global::System.Collections.Concurrent;
    using global::System.Collections.Generic;
    using global::System.Reflection;

    /// <summary>
    /// Compares two objects equality.
    /// </summary>
#if !OBeautifulCodeEqualitySolution
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [global::System.CodeDom.Compiler.GeneratedCode("OBeautifulCode.Equality.Recipes", "See package version number")]
    internal
#else
    public
#endif
    class ObjectEqualityComparer : IEqualityComparer<object>
    {
        private static readonly MethodInfo IsEqualToGenericMethod = typeof(EqualityExtensions).GetMethod(nameof(EqualityExtensions.IsEqualTo));

        private static readonly ConcurrentDictionary<Type, MethodInfo> CachedRuntimeTypeToIsEqualToMethodMap = new ConcurrentDictionary<Type, MethodInfo>();

        /// <inheritdoc />
        public new bool Equals(
            object x,
            object y)
        {
            // If both are null, or both are same instance, return true.
            if (ReferenceEquals(x, y))
            {
                return true;
            }

            // If one is null, but not both, return false.
            if (ReferenceEquals(x, null) || ReferenceEquals(y, null))
            {
                return false;
            }

            // If the objects don't have the same runtime type, return false.
            // As a consequence:
            //     new int[] { 1, 2 } != new List<int> { 1, 2 }
            // We accept this because there isn't a clear "contract" here.
            // Had the two objects been declared and compared as IReadOnlyList<int>, the contract
            // is determined to be an ordered collection, following that code path.
            // What if instead of List<int> in the above, we used Collection<int>?
            // How do you compare an ordered and unordered collection?  It's not clear.
            // The only sensible thing to do here is to require the runtime types to be equal
            // and if they are, treat the runtime types as the declared type and use the IsEqualTo
            // front-door.
            var runtimeType = x.GetType();

            if (runtimeType != y.GetType())
            {
                return false;
            }

            // new object() == new object()
            if (runtimeType == typeof(object))
            {
                return true;
            }

            // Per the above, use the IsEqualTo front-door, treating the runtime type as the declared type.
            if (!CachedRuntimeTypeToIsEqualToMethodMap.TryGetValue(runtimeType, out var isEqualToMethod))
            {
                isEqualToMethod = IsEqualToGenericMethod.MakeGenericMethod(runtimeType);

                CachedRuntimeTypeToIsEqualToMethodMap.TryAdd(runtimeType, isEqualToMethod);
            }

            var result = (bool)isEqualToMethod.Invoke(null, new[] { x, y, null });

            return result;
        }

        /// <inheritdoc />
        public int GetHashCode(
            object obj)
        {
            return HashCodeHelper.Initialize().Hash(obj).Value;
        }
    }
}
