// --------------------------------------------------------------------------------------------------------------------
// <copyright file="TypeExtensions.cs" company="OBeautifulCode">
//   Copyright (c) OBeautifulCode 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in OBeautifulCode.Type.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.Type.Recipes
{
    using global::System;
    using global::System.CodeDom;
    using global::System.CodeDom.Compiler;
    using global::System.Collections;
    using global::System.Collections.Concurrent;
    using global::System.Collections.Generic;
    using global::System.Collections.ObjectModel;
    using global::System.Diagnostics.CodeAnalysis;
    using global::System.Globalization;
    using global::System.Linq;
    using global::System.Reflection;
    using global::System.Runtime.CompilerServices;
    using global::System.Text.RegularExpressions;

    using OBeautifulCode.CodeAnalysis.Recipes;

    using static global::System.FormattableString;

    /// <summary>
    /// Extension methods on type <see cref="Type"/>.
    /// </summary>
    /// <remarks>
    /// These resources helped:
    /// <a href="https://stackoverflow.com/questions/13012733/difference-between-type-isgenerictypedefinition-and-type-containsgenericparamete" />.
    /// <a href="https://stackoverflow.com/questions/2173107/what-exactly-is-an-open-generic-type-in-net" />.
    /// <a href="https://stackoverflow.com/questions/1735035/generics-open-and-closed-constructed-types" />.
    /// <a href="https://stackoverflow.com/questions/25811514/detect-if-a-generic-type-is-open" />.
    /// <a href="https://docs.microsoft.com/en-us/dotnet/api/system.type.isgenerictype" />.
    /// <a href="https://stackoverflow.com/questions/31772922/difference-between-isgenerictype-and-isgenerictypedefinition" />.
    /// <a href="https://stackoverflow.com/questions/59144791/if-type-isgenericparameter-true-will-type-containsgenericparameters-true?noredirect=1#comment104515860_59144791" />.
    /// <a href="https://stackoverflow.com/questions/59141721/why-is-the-basetype-of-a-generic-type-definition-not-itself-a-generic-type-defin?noredirect=1#comment104515814_59141721" />.
    /// </remarks>
#if !OBeautifulCodeTypeSolution
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [global::System.CodeDom.Compiler.GeneratedCode("OBeautifulCode.Type.Recipes", "See package version number")]
    internal
#else
    public
#endif
    static class TypeExtensions
    {
        private static readonly Type ObjectType = typeof(object);

        private static readonly Type EnumerableInterfaceType = typeof(IEnumerable);

        private static readonly Type DictionaryInterfaceType = typeof(IDictionary);

        private static readonly Type EnumerableInterfaceGenericTypeDefinition = typeof(IEnumerable<>);

        private static readonly Type DictionaryInterfaceGenericTypeDefinition = typeof(IDictionary<,>);

        private static readonly Type ReadOnlyDictionaryInterfaceGenericTypeDefinition = typeof(IReadOnlyDictionary<,>);

        private static readonly Type ComparableInterfaceType = typeof(IComparable);

        private static readonly Type ComparableInterfaceGenericTypeDefinition = typeof(IComparable<>);

        private static readonly Regex GenericBracketsRegex = new Regex("<.*>", RegexOptions.Compiled);

        private static readonly CodeDomProvider CodeDomProvider = CodeDomProvider.CreateProvider("CSharp");

        private static readonly HashSet<Type> SystemCollectionGenericTypeDefinitions =
            new HashSet<Type>(new[]
            {
                typeof(Collection<>),
                typeof(ICollection<>),
                typeof(ReadOnlyCollection<>),
                typeof(IReadOnlyCollection<>),
                typeof(List<>),
                typeof(IList<>),
                typeof(IReadOnlyList<>),
            });

        private static readonly HashSet<Type> SystemOrderedCollectionGenericTypeDefinitions =
            new HashSet<Type>(new[]
            {
                typeof(Collection<>),
                typeof(ReadOnlyCollection<>),
                typeof(List<>),
                typeof(IList<>),
                typeof(IReadOnlyList<>),
            });

        private static readonly HashSet<Type> SystemUnorderedCollectionGenericTypeDefinitions =
            new HashSet<Type>(new[]
            {
                typeof(ICollection<>),
                typeof(IReadOnlyCollection<>),
            });

        private static readonly HashSet<Type> SystemDictionaryGenericTypeDefinitions =
            new HashSet<Type>(new[]
            {
                typeof(Dictionary<,>),
                typeof(IDictionary<,>),
                typeof(ReadOnlyDictionary<,>),
                typeof(IReadOnlyDictionary<,>),
                typeof(ConcurrentDictionary<,>),
            });

        private static readonly IReadOnlyDictionary<Type, string> ValueTypeToAliasMap =
            new Dictionary<Type, string>
            {
                { typeof(byte), "byte" },
                { typeof(sbyte), "sbyte" },
                { typeof(short), "short" },
                { typeof(ushort), "ushort" },
                { typeof(int), "int" },
                { typeof(uint), "uint" },
                { typeof(long), "long" },
                { typeof(ulong), "ulong" },
                { typeof(float), "float" },
                { typeof(double), "double" },
                { typeof(decimal), "decimal" },
                { typeof(object), "object" },
                { typeof(bool), "bool" },
                { typeof(char), "char" },
                { typeof(string), "string" },
                { typeof(void), "void" },
            };

        /// <summary>
        /// Determines the kind of array that the specified type is.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>
        /// The kind of array of the specified type.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static ArrayKind GetArrayKind(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            ArrayKind result;

            if (!type.IsArray)
            {
                result = ArrayKind.None;
            }
            else if (type.GetArrayRank() > 1)
            {
                result = ArrayKind.Multidimensional;
            }
            else if (type == type.GetElementType().MakeArrayType())
            {
                result = ArrayKind.Vector;
            }
            else
            {
                result = ArrayKind.Multidimensional;
            }

            return result;
        }

        /// <summary>
        /// Gets the type of the elements of a specified closed Enumerable type.
        /// </summary>
        /// <param name="type">The closed Enumerable type.</param>
        /// <returns>
        /// The type of the elements of the specified closed Enumerable type.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="type"/> is not a closed Enumerable type.</exception>
        public static Type GetClosedEnumerableElementType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (type.ContainsGenericParameters || (!EnumerableInterfaceType.IsAssignableFrom(type)))
            {
                throw new ArgumentException(Invariant($"Specified type is not a closed Enumerable type: {type.Name}."));
            }

            Type result;
            if (type.IsArray)
            {
                // type is array, shortcut
                result = type.GetElementType();
            }
            else if (type.IsGenericType && (type.GetGenericTypeDefinition() == EnumerableInterfaceGenericTypeDefinition))
            {
                // type is IEnumerable<T>
                result = type.GenericTypeArguments[0];
            }
            else
            {
                // type implements IEnumerable<T> or inherits it
                // note that we are grabbing the first implementation
                // it is possible, but highly unlikely, for a type to have multiple implementations of IEnumerable<T>
                result = type
                    .GetInterfaces()
                    .Where(_ => _.IsGenericType && (_.GetGenericTypeDefinition() == EnumerableInterfaceGenericTypeDefinition))
                    .Select(_ => _.GenericTypeArguments[0])
                    .FirstOrDefault();

                if (result == null)
                {
                    // we don't have to check BaseType, because you cannot derive from an array
                    // and all of the inherited interfaces are returned by GetInterfaces()
                    // at this point we know that this type is an IEnumerable
                    result = ObjectType;
                }
            }

            return result;
        }

        /// <summary>
        /// Gets the type of the keys of a specified closed Dictionary type.
        /// </summary>
        /// <param name="type">The closed Dictionary type.</param>
        /// <returns>
        /// The type of the keys of the specified closed Dictionary type.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="type"/> is not a closed Dictionary type.</exception>
        public static Type GetClosedDictionaryKeyType(
            this Type type)
        {
            var result = type.GetClosedDictionaryKeyOrValueTypeInternal(genericTypeArgumentIndex: 0);

            return result;
        }

        /// <summary>
        /// Gets the type of the values of a specified closed Dictionary type.
        /// </summary>
        /// <param name="type">The closed Dictionary type.</param>
        /// <returns>
        /// The type of the values of the specified closed Dictionary type.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="type"/> is not a closed Dictionary type.</exception>
        public static Type GetClosedDictionaryValueType(
            this Type type)
        {
            var result = type.GetClosedDictionaryKeyOrValueTypeInternal(genericTypeArgumentIndex: 1);

            return result;
        }

        /// <summary>
        /// Gets the type of the elements of the specified closed <see cref="System"/> Collection type.
        /// </summary>
        /// <param name="type">The closed <see cref="System"/> Collection type.</param>
        /// <returns>
        /// The type of the elements of the specified closed <see cref="System"/> Collection type.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="type"/> is not a closed <see cref="System"/> Collection type.  See <see cref="IsClosedSystemCollectionType(Type)"/>.</exception>
        public static Type GetClosedSystemCollectionElementType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (!type.IsClosedSystemCollectionType())
            {
                throw new ArgumentException(Invariant($"Specified type is not a closed System Collection type: {type.Name}."));
            }

            var result = type.GenericTypeArguments.First();

            return result;
        }

        /// <summary>
        /// Gets the type of the keys of the specified closed <see cref="System"/> Dictionary type.
        /// </summary>
        /// <param name="type">The closed <see cref="System"/> Dictionary type.</param>
        /// <returns>
        /// The type of the keys of the specified closed <see cref="System"/> Dictionary type.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="type"/> is not a closed <see cref="System"/> Dictionary type.  See <see cref="IsClosedSystemDictionaryType(Type)"/>.</exception>
        public static Type GetClosedSystemDictionaryKeyType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (!type.IsClosedSystemDictionaryType())
            {
                throw new ArgumentException(Invariant($"Specified type is not a closed System Dictionary type: {type.Name}."));
            }

            var result = type.GenericTypeArguments[0];

            return result;
        }

        /// <summary>
        /// Gets the type of the values of the specified closed <see cref="System"/> Dictionary type.
        /// </summary>
        /// <param name="type">The closed <see cref="System"/> Dictionary type.</param>
        /// <returns>
        /// The type of the values of the specified closed <see cref="System"/> Dictionary type.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="type"/> is not a closed <see cref="System"/> Dictionary type.  See <see cref="IsClosedSystemDictionaryType(Type)"/>.</exception>
        public static Type GetClosedSystemDictionaryValueType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (!type.IsClosedSystemDictionaryType())
            {
                throw new ArgumentException(Invariant($"Specified type is not a closed System Dictionary type: {type.Name}."));
            }

            var result = type.GenericTypeArguments[1];

            return result;
        }

        /// <summary>
        /// Gets the generic type definition of a specified type if the type is generic
        /// but not a generic type definition, otherwise returns the specified type.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>
        /// If the specified type is a generic type but not a generic type definition then the
        /// generic type definition is returned, otherwise the specified type is returned.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static Type GetGenericTypeDefinitionOrSpecifiedType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            var result = type.IsGenericType && (!type.IsGenericTypeDefinition)
                ? type.GetGenericTypeDefinition()
                : type;

            return result;
        }

        /// <summary>
        /// Gets the types in the inheritance path starting from the specified type's
        /// <see cref="Type.BaseType"/> and ending in a type with no <see cref="Type.BaseType"/>.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>
        /// The <see cref="Type.BaseType"/> of <paramref name="type"/>, followed by that type's
        /// <see cref="Type.BaseType"/>, and so on until a type has no <see cref="Type.BaseType"/>
        /// (that property returns null).
        /// If <paramref name="type"/> has no <see cref="Type.BaseType"/>, then this method returns
        /// an empty list.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="type"/> is not assignable to <see cref="EnumerableInterfaceType"/>.</exception>
        public static IReadOnlyList<Type> GetInheritancePath(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            var result = new List<Type>();

            type.BuildInheritancePath(result);

            return result;
        }

        /// <summary>
        /// Determines if the specified type has a default (public parameterless) constructor.
        /// </summary>
        /// <param name="type">Type to check.</param>
        /// <returns>
        /// A value indicating whether or not the type has a default (public parameterless) constructor.
        /// </returns>
        public static bool HasDefaultConstructor(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (type.ContainsGenericParameters)
            {
                return false;
            }

            var defaultConstructor = type.GetConstructors(BindingFlags.Public | BindingFlags.Instance).SingleOrDefault(_ => _.GetParameters().Length == 0);

            var result = defaultConstructor != null;

            return result;
        }

        /// <summary>
        /// Determines if the specified type has a base type.
        /// </summary>
        /// <returns>
        /// true if the specified type has a base type, otherwise false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool HasBaseType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            var result = type.BaseType != null;

            return result;
        }

        /// <summary>
        /// Determines if the base type of the specified type is object.
        /// </summary>
        /// <returns>
        /// true if the base type of the specified type is object, otherwise false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool HasObjectAsBaseType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            var result = type.BaseType == typeof(object);

            return result;
        }

        /// <summary>
        /// Determines if <see cref="Comparer{T}.Default"/> will return a
        /// working (non-throwing) comparer for the specified type.
        /// </summary>
        /// <remarks>
        /// See remarks in <see cref="HasWorkingDefaultComparer(Type)"/>.
        /// </remarks>
        /// <typeparam name="T">The type.</typeparam>
        /// <returns>
        /// true if <see cref="Comparer{T}.Default"/> returns a working (non-throwing)
        /// comparer for the specified type, otherwise false.
        /// </returns>
        public static bool HasWorkingDefaultComparer<T>()
        {
            var type = typeof(T);

            var result = HasWorkingDefaultComparer(type);

            return result;
        }

        /// <summary>
        /// Determines if <see cref="Comparer{T}.Default"/> will return a
        /// working (non-throwing) comparer for the specified type.
        /// </summary>
        /// <remarks>
        /// <see cref="Comparer{T}.Default" /> will always return some comparer for
        /// any given closed type.  However, that comparer, when used, will or will no
        /// throw based on the type itself.  If the type implements or inherits <see cref="IComparable{T}"/>
        /// where T is itself, then the comparer will ultimately use that implementation.
        /// We say "ultimately" here and below because a wrapper object is used.
        /// If the type is nullable and the underlying type implements or inherits <see cref="IComparable{T}"/>
        /// where T is the underlying type, then the comparer will ultimately use that implementation.
        /// Finally, if the the type, when boxed, implements or inherits <see cref="IComparable"/> then the comparer
        /// will ultimately use that implementation.  If not, then, upon using the comparer to compare two
        /// objects, an exception will be thrown.
        /// It's further important to note that this method is NOT simply checking whether the specified
        /// type is assignable to <see cref="IComparable{T}"/>.  For example:
        /// typeof(IComparable&lt;string&gt;).HasWorkingDefaultComparer() == false
        /// That's because that type doesn't implement IComparable&lt;IComparable&lt;string&gt;&gt;
        /// per the heuristic described above.  That said, any type that is assignable to <see cref="IComparable"/>
        /// will return true per the heuristic above.  For example:
        /// typeof(IComparable).HasWorkingDefaultComparer() == true.
        /// </remarks>
        /// <param name="type">The type.</param>
        /// <returns>
        /// true if <see cref="Comparer{T}.Default"/> returns a working (non-throwing)
        /// comparer for the specified type, otherwise false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        /// <exception cref="NotSupportedException"><paramref name="type"/> is an open type.</exception>
        public static bool HasWorkingDefaultComparer(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            // you cannot call Comparer{T}.Default on a closed type,
            // not even using reflection
            if (type.ContainsGenericParameters)
            {
                throw new NotSupportedException(Invariant($"Parameter '{nameof(type)}' is an open type; open types are not supported for that parameter."));
            }

            // Previously, we called Comparer<T>.Default and checked whether that was equal to ObjectComparer<T>.
            // If so, we considered the type to be NOT comparable.  Comparer<T>.Default checks, among other things,
            // whether T is IComparable<T>.  Unfortunately, types like Enum don't implement IComparable<T>,
            // but are IComparable.  So for enums, Comparer<T>.Default returns ObjectComparer<T>.  It turns out,
            // ObjectComparer<T> doesn't just check for reference equality.  Among other things, it checks whether
            // the type is IComparable.  So we combined the approach taken by Comparer<T>.Default and ObjectComparer<T>
            // into the follow...
            var genericComparableType = ComparableInterfaceGenericTypeDefinition.MakeGenericType(type);

            if (genericComparableType.IsAssignableFrom(type))
            {
                return true;
            }

            if (type.IsClosedNullableType())
            {
                var underlyingType = type.GenericTypeArguments[0];

                var underlyingGenericComparableType = ComparableInterfaceGenericTypeDefinition.MakeGenericType(underlyingType);

                if (underlyingGenericComparableType.IsAssignableFrom(underlyingType))
                {
                    return true;
                }
            }

            // Is type boxed to IComparable?
            // for example, Nullable<Enum> is not IComparable, but it boxes to Enum which is:
            // https://docs.microsoft.com/en-us/dotnet/api/system.nullable?view=netframework-4.8
            // https://stackoverflow.com/questions/59180389/given-a-type-how-do-you-determine-what-type-it-is-boxed-as#59180620
            var boxedType = Nullable.GetUnderlyingType(type) ?? type;

            var result = ComparableInterfaceType.IsAssignableFrom(boxedType);

            return result;
        }

        /// <summary>
        /// Determines if a type if assignable to another type.
        /// </summary>
        /// <remarks>
        /// Adapted from: <a href="https://stackoverflow.com/questions/74616/how-to-detect-if-type-is-another-generic-type/1075059#1075059" />.
        /// </remarks>
        /// <param name="type">The current type.</param>
        /// <param name="otherType">The type to check for ability to assign to.</param>
        /// <param name="treatGenericTypeDefinitionAsAssignableTo">If <paramref name="otherType"/> is a generic type definition, specifies whether the method should treat that type as if a closed type can be assigned to it (e.g. IsAssignableTo(List&lt;int&gt;, List&lt;&gt;)).</param>
        /// <returns>
        /// true if <paramref name="type"/> can be assigned to <paramref name="otherType"/>; otherwise false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="otherType"/> is null.</exception>
        /// <exception cref="NotSupportedException"><paramref name="type"/> is an open type.</exception>
        /// <exception cref="NotSupportedException"><paramref name="otherType"/> is an open type, but not a generic type definition.</exception>
        public static bool IsAssignableTo(
            this Type type,
            Type otherType,
            bool treatGenericTypeDefinitionAsAssignableTo = false)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (otherType == null)
            {
                throw new ArgumentNullException(nameof(otherType));
            }

            if (type.ContainsGenericParameters)
            {
                throw new NotSupportedException(Invariant($"Parameter '{nameof(type)}' is an open type; open types are not supported for that parameter."));
            }

            if ((!otherType.IsGenericTypeDefinition) && otherType.ContainsGenericParameters)
            {
                throw new NotSupportedException(Invariant($"Parameter '{nameof(otherType)}' is an open type, but not a generic type definition; the only open types that are supported are generic type definitions for that parameter."));
            }

            // type is equal to the other type
            if (type == otherType)
            {
                return true;
            }

            // type is assignable to the other type
            if (otherType.IsAssignableFrom(type))
            {
                return true;
            }

            // other type is a generic type definition and we are treating the specified closed type as if it can be assigned to a generic type definition
            if (treatGenericTypeDefinitionAsAssignableTo && otherType.IsGenericTypeDefinition)
            {
                // type's generic type definition is the other type
                if (type.IsGenericType && type.GetGenericTypeDefinition() == otherType)
                {
                    return true;
                }

                // type implements an interface who's generic type definition is the other type
                if (type.GetInterfaces().Any(_ => _.IsGenericType && (_.GetGenericTypeDefinition() == otherType)))
                {
                    return true;
                }

                // the type has a base type?
                var baseType = type.BaseType;
                if (baseType == null)
                {
                    return false;
                }

                // check if the base types are assignable to the other type
                // note that we don't need to check the interfaces that the base type
                // implements because the GetInterfaces() call above returns all the interfaces implemented or inherited
                if (type.GetInheritancePath().Any(_ => _.IsGenericType && (_.GetGenericTypeDefinition() == otherType)))
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Determines if the specified type is closed and assignable to null.
        /// </summary>
        /// <remarks>
        /// Adapted from: <a href="https://stackoverflow.com/a/1770232/356790" />.
        /// </remarks>
        /// <param name="type">The type.</param>
        /// <returns>
        /// true if the specified type is closed and assignable to null, otherwise false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool IsClosedTypeAssignableToNull(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (type.ContainsGenericParameters)
            {
                return false;
            }

            var result = (!type.IsValueType) || type.IsClosedNullableType();

            return result;
        }

        /// <summary>
        /// Determines if a type is a closed anonymous type.
        /// </summary>
        /// <param name="type">Type to check.</param>
        /// <returns>A value indicating whether or not the type provided is a closed anonymous type.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool IsClosedAnonymousType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (type.ContainsGenericParameters)
            {
                return false;
            }

            var result = type.IsAnonymousType();

            return result;
        }

        /// <summary>
        /// Determines if a type is a closed anonymous type using a faster, but potentially
        /// less accurate heuristic than <see cref="IsClosedAnonymousType(Type)"/>.
        /// </summary>
        /// <param name="type">Type to check.</param>
        /// <returns>A value indicating whether or not the type provided is a closed anonymous type.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool IsClosedAnonymousTypeFastCheck(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (type.ContainsGenericParameters)
            {
                return false;
            }

            var result = type.Namespace == null;

            return result;
        }

        /// <summary>
        /// Determines if the specified type is a closed generic type.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>
        /// true if the specified type is a closed generic type; otherwise false.
        /// </returns>
        public static bool IsClosedGenericType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            var result = type.IsGenericType && (!type.ContainsGenericParameters);

            return result;
        }

        /// <summary>
        /// Determines if the specified type is a class type, that's not anonymous, and is closed.
        /// </summary>
        /// <remarks>
        /// This is basically asking, "Is this a class type that can be constructed/new-ed up?".
        /// </remarks>
        /// <param name="type">The type.</param>
        /// <returns>
        /// true if the specified type is a class type, non-anonymous, and closed.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool IsClosedNonAnonymousClassType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            var result =
                type.IsClass
                && (!type.ContainsGenericParameters)
                && (!type.IsAnonymousType());

            return result;
        }

        /// <summary>
        /// Determines if the specified type is a closed <see cref="Nullable{T}"/> type.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>
        /// true if the specified type is a closed <see cref="Nullable{T}"/> type, otherwise false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool IsClosedNullableType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (type.ContainsGenericParameters)
            {
                return false;
            }

            var result = type.IsNullableType();

            return result;
        }

        /// <summary>
        /// Determines if the specified type is a closed version of one of the
        /// following <see cref="System"/> Collection generic type definitions:
        /// <see cref="SystemCollectionGenericTypeDefinitions"/>.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>
        /// true if the specified type is a closed <see cref="System"/> collection type; otherwise false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool IsClosedSystemCollectionType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (type.ContainsGenericParameters)
            {
                return false;
            }

            var result = type.IsSystemCollectionType();

            return result;
        }

        /// <summary>
        /// Determines if the specified type is a closed version one of one of the
        /// following <see cref="System"/> Dictionary generic type definitions:
        /// <see cref="SystemDictionaryGenericTypeDefinitions"/>.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>
        /// true if the specified type is a closed <see cref="System"/> dictionary type; otherwise false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool IsClosedSystemDictionaryType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (type.ContainsGenericParameters)
            {
                return false;
            }

            var result = type.IsSystemDictionaryType();

            return result;
        }

        /// <summary>
        /// Determines if the specified type is a closed <see cref="IEnumerable{T}"/>.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>
        /// true if the specified type is a closed <see cref="IEnumerable{T}"/>; otherwise false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool IsClosedSystemEnumerableType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (type.ContainsGenericParameters)
            {
                return false;
            }

            var result = type.IsSystemEnumerableType();

            return result;
        }

        /// <summary>
        /// Determines if the specified type is a closed version of one of the
        /// following ordered <see cref="System"/> Collection generic type definitions:
        /// <see cref="SystemOrderedCollectionGenericTypeDefinitions"/>.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>
        /// true if the specified type is a closed, ordered <see cref="System"/> Collection type; otherwise false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool IsClosedSystemOrderedCollectionType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (type.ContainsGenericParameters)
            {
                return false;
            }

            var result = type.IsSystemOrderedCollectionType();

            return result;
        }

        /// <summary>
        /// Determines if the specified type is a closed version of one of the
        /// following unordered <see cref="System"/> Collection generic type definitions:
        /// <see cref="SystemUnorderedCollectionGenericTypeDefinitions"/>.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>
        /// true if the specified type is a closed, unordered <see cref="System"/> Collection type; otherwise false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool IsClosedSystemUnorderedCollectionType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (type.ContainsGenericParameters)
            {
                return false;
            }

            var result = type.IsSystemUnorderedCollectionType();

            return result;
        }

        /// <summary>
        /// Determines if the specified type is an open or closed <see cref="Nullable{T}"/> type.
        /// </summary>
        /// <remarks>Adapted from: <a href="https://stackoverflow.com/a/41281601/356790" />.</remarks>
        /// <param name="type">The type.</param>
        /// <returns>
        /// true if the specified type is an open or closed <see cref="Nullable{T}"/> type, otherwise false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool IsNullableType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            var result = (type == typeof(Nullable<>)) || (Nullable.GetUnderlyingType(type) != null);

            return result;
        }

        /// <summary>
        /// Determines if the specified type is in the <see cref="System"/> namespace.
        /// </summary>
        /// <remarks>
        /// An array is considered a system type.
        /// A ValueTuple is considered a system type.
        /// A generic type parameter is considered a system type.
        /// An anonymous type is not considered a system type.
        /// </remarks>
        /// <param name="type">The type.</param>
        /// <returns>
        /// true if the specified type is in the <see cref="System"/> namespace, otherwise false.
        /// </returns>
        public static bool IsSystemType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            var result = type.IsArray || type.IsGenericParameter || (type.Namespace?.StartsWith(nameof(System), StringComparison.Ordinal) ?? false);

            return result;
        }

        /// <summary>
        /// Determines if the specified type is an open or closed version of one of the
        /// following <see cref="System"/> Collection generic type definitions:
        /// <see cref="SystemCollectionGenericTypeDefinitions"/>.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>
        /// true if the specified type is a closed <see cref="System"/> collection type; otherwise false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool IsSystemCollectionType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (!type.IsGenericType)
            {
                return false;
            }

            var genericTypeDefinition = type.GetGenericTypeDefinition();

            var result = SystemCollectionGenericTypeDefinitions.Contains(genericTypeDefinition);

            return result;
        }

        /// <summary>
        /// Determines if the specified type is an open or closed version one of one of the
        /// following <see cref="System"/> Dictionary generic type definitions:
        /// <see cref="SystemDictionaryGenericTypeDefinitions"/>.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>
        /// true if the specified type is a closed <see cref="System"/> dictionary type; otherwise false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool IsSystemDictionaryType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (!type.IsGenericType)
            {
                return false;
            }

            var genericTypeDefinition = type.GetGenericTypeDefinition();

            var result = SystemDictionaryGenericTypeDefinitions.Contains(genericTypeDefinition);

            return result;
        }

        /// <summary>
        /// Determines if the specified type is an open or closed <see cref="IEnumerable{T}"/>.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>
        /// true if the specified type is a closed <see cref="IEnumerable{T}"/>; otherwise false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool IsSystemEnumerableType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (!type.IsGenericType)
            {
                return false;
            }

            var genericTypeDefinition = type.GetGenericTypeDefinition();

            var result = genericTypeDefinition == EnumerableInterfaceGenericTypeDefinition;

            return result;
        }

        /// <summary>
        /// Determines if the specified type is an open or closed version of one of the
        /// following ordered <see cref="System"/> Collection generic type definitions:
        /// <see cref="SystemOrderedCollectionGenericTypeDefinitions"/>.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>
        /// true if the specified type is a closed, ordered <see cref="System"/> Collection type; otherwise false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool IsSystemOrderedCollectionType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (!type.IsGenericType)
            {
                return false;
            }

            var genericTypeDefinition = type.GetGenericTypeDefinition();

            var result = SystemOrderedCollectionGenericTypeDefinitions.Contains(genericTypeDefinition);

            return result;
        }

        /// <summary>
        /// Determines if the specified type is an open or closed version of one of the
        /// following unordered <see cref="System"/> Collection generic type definitions:
        /// <see cref="SystemUnorderedCollectionGenericTypeDefinitions"/>.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>
        /// true if the specified type is a closed, unordered <see cref="System"/> Collection type; otherwise false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool IsSystemUnorderedCollectionType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (!type.IsGenericType)
            {
                return false;
            }

            var genericTypeDefinition = type.GetGenericTypeDefinition();

            var result = SystemUnorderedCollectionGenericTypeDefinitions.Contains(genericTypeDefinition);

            return result;
        }

        /// <summary>
        /// Determines if the specified type is assignable to null.
        /// </summary>
        /// <remarks>
        /// Adapted from: <a href="https://stackoverflow.com/a/1770232/356790" />.
        /// </remarks>
        /// <param name="type">The type.</param>
        /// <returns>
        /// true if the specified type is assignable to null, otherwise false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool IsTypeAssignableToNull(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            var result = (!type.IsValueType) || type.IsNullableType();

            return result;
        }

        /// <summary>
        /// Substitutes the elements of an array of types for the type parameters of the current
        /// generic type definition and returns a <see cref="Type"/> object representing the resulting constructed type
        /// or null if the operation cannot be performed.
        /// </summary>
        /// <param name="type">The generic type definition.</param>
        /// <param name="typeArguments">An array of types to be substituted for the type parameters of <paramref name="type"/>.</param>
        /// <returns>
        /// A <see cref="Type"/> representing the constructed type formed by substituting the
        /// elements of <paramref name="typeArguments"/> for the type parameters of <paramref name="type"/> or null
        /// if the operation cannot be performed.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static Type MakeGenericTypeOrNull(
            this Type type,
            params Type[] typeArguments)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            Type result;

            try
            {
                result = type.MakeGenericType(typeArguments);
            }
            catch (Exception)
            {
                result = null;
            }

            return result;
        }

        /// <summary>
        /// Gets a compilable, readability-optimized string representation of the specified type.
        /// </summary>
        /// <remarks>
        /// Adapted from: <a href="https://stackoverflow.com/a/6402967/356790" />.
        /// Adapted from: <a href="https://stackoverflow.com/questions/1362884/is-there-a-way-to-get-a-types-alias-through-reflection" />.
        /// </remarks>
        /// <param name="type">The type.</param>
        /// <param name="throwIfNoCompilableStringExists">Optional value indicating whether to throw a <see cref="NotSupportedException"/> if there's no compilable representation of the specified type.</param>
        /// <returns>
        /// A compilable, readability-optimized string representation of the specified type
        /// OR
        /// null if there is no compilable representation and <paramref name="throwIfNoCompilableStringExists"/> is true.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        /// <exception cref="NotSupportedException"><paramref name="throwIfNoCompilableStringExists"/> is true and <paramref name="type"/> is a generic open constructed type, which is not supported.</exception>
        /// <exception cref="NotSupportedException"><paramref name="throwIfNoCompilableStringExists"/> is true and <paramref name="type"/> is a generic parameter.</exception>
        public static string ToStringCompilable(
            this Type type,
            bool throwIfNoCompilableStringExists = false)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            string result;

            if (type.IsClosedAnonymousType())
            {
                if (throwIfNoCompilableStringExists)
                {
                    throw new NotSupportedException("Anonymous types are not supported.");
                }
                else
                {
                    result = null;
                }
            }
            else if (type.IsGenericParameter)
            {
                if (throwIfNoCompilableStringExists)
                {
                    // note that IsGenericParameter and ContainsGenericParameters will return true for generic parameters,
                    // hence we order the IsGenericParameter check first.
                    throw new NotSupportedException("Generic parameters not supported.");
                }
                else
                {
                    result = null;
                }
            }
            else
            {
                if (ValueTypeToAliasMap.ContainsKey(type))
                {
                    result = ValueTypeToAliasMap[type];
                }
                else if (type.IsClosedNullableType())
                {
                    result = Nullable.GetUnderlyingType(type).ToStringCompilable() + "?";
                }
                else if (type.IsArray)
                {
                    result = type.GetElementType().ToStringCompilable() + "[]";
                }
                else
                {
                    result = CodeDomProvider.GetTypeOutput(new CodeTypeReference(type.FullName?.Replace(type.Namespace + ".", string.Empty)));

                    if (type.IsGenericType)
                    {
                        if (type.IsGenericTypeDefinition)
                        {
                            result = result.Replace(" ", string.Empty);
                        }
                        else if (type.ContainsGenericParameters)
                        {
                            if (throwIfNoCompilableStringExists)
                            {
                                throw new NotSupportedException("Generic open constructed types are not supported.");
                            }
                            else
                            {
                                result = null;
                            }
                        }
                        else
                        {
                            var genericParameters = type.GenericTypeArguments.Select(_ => _.ToStringCompilable()).ToArray();

                            result = GenericBracketsRegex.Replace(result, "<" + string.Join(", ", genericParameters) + ">");
                        }
                    }
                }
            }

            return result;
        }

        /// <summary>
        /// Gets a readability-optimized string representation of the specified type.
        /// </summary>
        /// <remarks>
        /// Adapted from: <a href="https://stackoverflow.com/a/6402967/356790" />.
        /// Adapted from: <a href="https://stackoverflow.com/questions/1362884/is-there-a-way-to-get-a-types-alias-through-reflection" />.
        /// Helpful breakdown of generics: <a href="https://docs.microsoft.com/en-us/dotnet/api/system.type.isgenerictype" />.
        /// </remarks>
        /// <param name="type">The type.</param>
        /// <param name="options">The options to use when generating the string representation.</param>
        /// <returns>
        /// A readability-optimized string representation of the specified type.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static string ToStringReadable(
            this Type type,
            ToStringReadableOptions options = ToStringReadableOptions.None)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            var assemblyDetailsTypes = new List<Type>();

            var result = type.ToStringReadableInternal(options, assemblyDetailsTypes);

            var includeAssemblyDetails = options.HasFlag(ToStringReadableOptions.IncludeAssemblyDetails);

            if (includeAssemblyDetails && assemblyDetailsTypes.Any())
            {
                result = result + " || " + string.Join(" | ", assemblyDetailsTypes.Select(_ => _.ToAssemblyDetails()).ToArray());
            }

            return result;
        }

        /// <summary>
        /// Gets an XML-doc compatible string representation of the specified type.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <param name="throwIfNoCompatibleStringExists">Optional value indicating whether to throw a <see cref="NotSupportedException"/> if there's no compatible string representation of the specified type.</param>
        /// <param name="options">The options to use when generating the string representation.</param>
        /// <returns>
        /// A XML-doc compatible string representation of the specified type.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static string ToStringXmlDoc(
            this Type type,
            bool throwIfNoCompatibleStringExists = false,
            ToStringXmlDocOptions options = ToStringXmlDocOptions.None)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            string result;

            if (type.IsAnonymousType())
            {
                if (throwIfNoCompatibleStringExists)
                {
                    throw new NotSupportedException("Anonymous types are not supported.");
                }
                else
                {
                    result = null;
                }
            }
            else if (type.IsGenericParameter)
            {
                if (throwIfNoCompatibleStringExists)
                {
                    // note that IsGenericParameter and ContainsGenericParameters will return true for generic parameters,
                    // hence we order the IsGenericParameter check first.
                    throw new NotSupportedException("Generic parameters not supported.");
                }
                else
                {
                    result = null;
                }
            }
            else if (type.IsArray)
            {
                result = options.HasFlag(ToStringXmlDocOptions.IncludeNamespace) ? typeof(Array).FullName : nameof(Array);
            }
            else if (ValueTypeToAliasMap.ContainsKey(type))
            {
                result = ValueTypeToAliasMap[type];
            }
            else
            {
                result = CodeDomProvider.GetTypeOutput(new CodeTypeReference(type.FullName?.Replace(type.Namespace + ".", string.Empty) ?? type.Name));

                var includeNamespace = options.HasFlag(ToStringXmlDocOptions.IncludeNamespace);

                if (includeNamespace && (type.Namespace != null))
                {
                    result = type.Namespace + "." + result;
                }

                // as far as we can tell, you can't namespace qualify generic arguments
                // also multiple-levels of generics are not allow (e.g. List<List<string>> is represented as List{List})
                if (type.IsGenericType)
                {
                    var genericArgumentStrings = new List<string>();

                    foreach (var genericArgument in type.GetGenericArguments())
                    {
                        string genericArgumentString;

                        if (genericArgument.IsArray)
                        {
                            genericArgumentString = nameof(Array);
                        }
                        else
                        {
                            var genericTickIndex = genericArgument.Name.IndexOf('`');

                            genericArgumentString = genericTickIndex == -1 ? genericArgument.Name : genericArgument.Name.Substring(0, genericTickIndex);
                        }

                        genericArgumentStrings.Add(genericArgumentString);
                    }

                    result = GenericBracketsRegex.Replace(result, "{" + string.Join(", ", genericArgumentStrings) + "}");
                }
            }

            return result;
        }

        /// <summary>
        /// Gets a string representation of the specified type without the generic component.
        /// For example, Dictionary&lt;string, string&gt; would be represented as 'Dictionary'.
        /// </summary>
        /// <remarks>
        /// Adapted from: <a href="https://stackoverflow.com/a/6386234/356790" />.
        /// </remarks>
        /// <param name="type">The type.</param>
        /// <returns>
        /// A string representation of the specified type with the generic component stripped out.
        /// </returns>
        public static string ToStringWithoutGenericComponent(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            string result;
            if (ValueTypeToAliasMap.ContainsKey(type))
            {
                result = ValueTypeToAliasMap[type];
            }
            else if (type.IsArray)
            {
                result = type.GetElementType().ToStringWithoutGenericComponent() + "[]";
            }
            else
            {
                var isAnonymousType = type.IsAnonymousType();

                var name = type.Name;

                var index = name.IndexOf('`');

                result = index == -1 ? name : name.Substring(0, index);

                if (isAnonymousType)
                {
                    result = result.Replace("<>f__", string.Empty);
                }
            }

            return result;
        }

        /// <summary>
        /// Substitutes the elements of an array of types for the type parameters of the current
        /// generic type definition and returns a <see cref="Type"/> object representing the resulting constructed type.
        /// </summary>
        /// <param name="type">The generic type definition.</param>
        /// <param name="genericType">A <see cref="Type"/> representing the constructed type formed by substituting the elements of <paramref name="typeArguments"/> for the type parameters of <paramref name="type"/> or null if the operation cannot be performed.</param>
        /// <param name="typeArguments">An array of types to be substituted for the type parameters of <paramref name="type"/>.</param>
        /// <returns>
        /// true if the type was successfully constructed; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        [SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", MessageId = "1#", Justification = ObcSuppressBecause.CA1021_AvoidOutParameters_OutParameterRequiredForTryMethod)]
        public static bool TryMakeGenericType(
            this Type type,
            out Type genericType,
            params Type[] typeArguments)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            genericType = type.MakeGenericTypeOrNull(typeArguments);

            var result = genericType != null;

            return result;
        }

        private static void BuildInheritancePath(
            this Type type,
            List<Type> traversedPath)
        {
            if (type.BaseType != null)
            {
                traversedPath.Add(type.BaseType);

                type.BaseType.BuildInheritancePath(traversedPath);
            }
        }

        private static Type GetClosedDictionaryKeyOrValueTypeInternal(
            this Type type,
            int genericTypeArgumentIndex)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            // IReadOnlyDictionary<T,K> and IDictionary<T,K> don't implement IDictionary
            // hence the need for the additional IsAssignableTo checks.
            if (type.ContainsGenericParameters ||
                (
                       (!DictionaryInterfaceType.IsAssignableFrom(type))
                    && (!type.IsAssignableTo(DictionaryInterfaceGenericTypeDefinition, treatGenericTypeDefinitionAsAssignableTo: true))
                    && (!type.IsAssignableTo(ReadOnlyDictionaryInterfaceGenericTypeDefinition, treatGenericTypeDefinitionAsAssignableTo: true))))
            {
                throw new ArgumentException(Invariant($"Specified type is not a closed Dictionary type: {type.Name}."));
            }

            Type result;

            if (type.IsGenericType && (type.GetGenericTypeDefinition() == DictionaryInterfaceGenericTypeDefinition))
            {
                // type is IDictionary<T,K>
                result = type.GenericTypeArguments[genericTypeArgumentIndex];
            }
            else if (type.IsGenericType && (type.GetGenericTypeDefinition() == ReadOnlyDictionaryInterfaceGenericTypeDefinition))
            {
                // type is IReadOnlyDictionary<T,K>
                result = type.GenericTypeArguments[genericTypeArgumentIndex];
            }
            else
            {
                // type implements or inherits IDictionary<T,K>/IReadOnlyDictionary<T,K>
                // note that we are grabbing the first implementation
                // it is possible, but highly unlikely, for a type to have multiple implementations of IDictionary<T,K>/IReadOnlyDictionary<T,K>
                result = type
                    .GetInterfaces()
                    .Where(_ => _.IsGenericType && ((_.GetGenericTypeDefinition() == DictionaryInterfaceGenericTypeDefinition) || (_.GetGenericTypeDefinition() == ReadOnlyDictionaryInterfaceGenericTypeDefinition)))
                    .Select(_ => _.GenericTypeArguments[genericTypeArgumentIndex])
                    .FirstOrDefault();

                if (result == null)
                {
                    // we don't have to check BaseType; all of the inherited interfaces are returned by GetInterfaces()
                    // at this point we know that this type is an IDictionary
                    result = ObjectType;
                }
            }

            return result;
        }

        private static bool IsAnonymousType(
            this Type type)
        {
            var result = Attribute.IsDefined(type, typeof(CompilerGeneratedAttribute), false)
                         && type.Namespace == null
                         && type.IsGenericType
                         && type.Name.Contains("AnonymousType")
                         && (type.Name.StartsWith("<>", StringComparison.Ordinal) || type.Name.StartsWith("VB$", StringComparison.Ordinal))
                         && type.Attributes.HasFlag(TypeAttributes.NotPublic);

            return result;
        }

        private static string ToStringReadableInternal(
            this Type type,
            ToStringReadableOptions options,
            IList<Type> assemblyDetailsTypes = null)
        {
            string result;

            if (type.IsGenericParameter)
            {
                result = type.Name;
            }
            else if (ValueTypeToAliasMap.ContainsKey(type))
            {
                assemblyDetailsTypes?.Add(type);

                result = ValueTypeToAliasMap[type];
            }
            else if (type.IsClosedNullableType())
            {
                result = Nullable.GetUnderlyingType(type).ToStringReadableInternal(options, assemblyDetailsTypes) + "?";
            }
            else if (type.IsArray)
            {
                result = type.GetElementType().ToStringReadableInternal(options, assemblyDetailsTypes) + "[]";
            }
            else
            {
                assemblyDetailsTypes?.Add(type);

                result = CodeDomProvider.GetTypeOutput(new CodeTypeReference(type.FullName?.Replace(type.Namespace + ".", string.Empty) ?? type.Name));

                var includeNamespace = options.HasFlag(ToStringReadableOptions.IncludeNamespace);
                if (includeNamespace && (type.Namespace != null))
                {
                    result = type.Namespace + "." + result;
                }

                if (type.IsGenericType)
                {
                    var isAnonymousType = type.IsAnonymousType();

                    if (isAnonymousType)
                    {
                        result = result.Replace("<>f__", string.Empty);
                    }

                    string[] genericParameters;
                    if (isAnonymousType && type.ContainsGenericParameters)
                    {
                        genericParameters = type.GetGenericArguments().Select((_, i) => "T" + (i + 1).ToString(CultureInfo.InvariantCulture)).ToArray();
                    }
                    else
                    {
                        genericParameters = type.GetGenericArguments().Select(_ => _.ToStringReadableInternal(options, assemblyDetailsTypes)).ToArray();
                    }

                    result = GenericBracketsRegex.Replace(result, "<" + string.Join(", ", genericParameters) + ">");
                }
            }

            return result;
        }

        private static string ToAssemblyDetails(
            this Type type)
        {
            if (type.IsGenericType)
            {
                type = type.GetGenericTypeDefinition();
            }

            var fullyQualifiedTypeName = type.ToStringReadableInternal(ToStringReadableOptions.IncludeNamespace);

            var assemblyName = type.Assembly.GetName();

            var result = fullyQualifiedTypeName + " => " + assemblyName.Name + " (" + assemblyName.Version + ")";

            return result;
        }
    }
}
