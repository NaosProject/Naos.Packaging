// --------------------------------------------------------------------------------------------------------------------
// <copyright file="Verifications.TypeValidation.cs" company="OBeautifulCode">
//   Copyright (c) OBeautifulCode 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in OBeautifulCode.Assertion.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.Assertion.Recipes
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Globalization;
    using System.Linq;

    using OBeautifulCode.Type.Recipes;

    using static System.FormattableString;

#if !OBeautifulCodeAssertionRecipesProject
    internal
#else
    public
#endif
        static partial class Verifications
    {
#pragma warning disable SA1201
        private static readonly Type EnumerableType = typeof(IEnumerable);

        private static readonly Type ComparableType = typeof(IComparable);

        private static readonly Type UnboundGenericComparableType = typeof(IComparable<>);

        private static readonly Type BoolType = typeof(bool);

        private static readonly Type NullableBoolType = typeof(bool?);

        private static readonly Type StringType = typeof(string);

        private static readonly Type GuidType = typeof(Guid);

        private static readonly Type NullableGuidType = typeof(Guid?);

        private static readonly Type DictionaryType = typeof(IDictionary);

        private static readonly Type UnboundGenericDictionaryType = typeof(IDictionary<,>);

        private static readonly Type UnboundGenericReadOnlyDictionaryType = typeof(IReadOnlyDictionary<,>);

        private static readonly Type NullableType = typeof(Nullable<>);

        private static readonly IReadOnlyCollection<TypeValidation> MustBeNullableTypeValidations = new[]
        {
            new TypeValidation
            {
                Handler = ThrowIfTypeCannotBeNull,
            },
        };

        private static readonly IReadOnlyCollection<TypeValidation> MustBeBooleanTypeValidations = new[]
        {
            new TypeValidation
            {
                Handler = ThrowIfNotOfType,
                ReferenceTypes = new[] { BoolType, NullableBoolType },
            },
        };

        private static readonly IReadOnlyCollection<TypeValidation> MustBeStringTypeValidations = new[]
        {
            new TypeValidation
            {
                Handler = ThrowIfNotOfType,
                ReferenceTypes = new[] { StringType },
            },
        };

        private static readonly IReadOnlyCollection<TypeValidation> MustBeGuidTypeValidations = new[]
        {
            new TypeValidation
            {
                Handler = ThrowIfNotOfType,
                ReferenceTypes = new[] { GuidType, NullableGuidType },
            },
        };

        private static readonly IReadOnlyCollection<TypeValidation> MustBeEnumerableTypeValidations = new[]
        {
            new TypeValidation
            {
                Handler = ThrowIfNotOfType,
                ReferenceTypes = new[] { EnumerableType },
            },
        };

        private static readonly IReadOnlyCollection<TypeValidation> MustBeEnumerableOfNullableTypeValidations = new[]
        {
            new TypeValidation
            {
                Handler = ThrowIfNotOfType,
                ReferenceTypes = new[] { EnumerableType },
            },
            new TypeValidation
            {
                Handler = ThrowIfEnumerableTypeCannotBeNull,
            },
        };

        private static readonly IReadOnlyCollection<TypeValidation> MustBeDictionaryTypeValidations = new[]
        {
            new TypeValidation
            {
                Handler = ThrowIfNotOfType,
                ReferenceTypes = new[] { DictionaryType, UnboundGenericDictionaryType, UnboundGenericReadOnlyDictionaryType },
            },
        };

        private static readonly IReadOnlyCollection<TypeValidation> MustBeDictionaryOfNullableTypeValidations = new[]
        {
            new TypeValidation
            {
                Handler = ThrowIfNotOfType,
                ReferenceTypes = new[] { DictionaryType, UnboundGenericDictionaryType, UnboundGenericReadOnlyDictionaryType },
            },
            new TypeValidation
            {
                Handler = ThrowIfDictionaryTypeCannotBeNull,
            },
        };

        private static readonly IReadOnlyCollection<TypeValidation> InequalityTypeValidations = new[]
        {
            new TypeValidation
            {
                Handler = ThrowIfNotOfType,
                ReferenceTypes = new[] { ComparableType, UnboundGenericComparableType, NullableType },
            },
            new TypeValidation
            {
                Handler = ThrowIfAnyVerificationParameterTypeDoesNotEqualValueType,
            },
        };

        private static readonly IReadOnlyCollection<TypeValidation> BeSameReferenceAsTypeValidations = new[]
        {
            new TypeValidation
            {
                Handler = ThrowIfValueType,
            },
            new TypeValidation
            {
                Handler = ThrowIfAnyVerificationParameterTypeDoesNotEqualValueType,
            },
        };

        private static readonly IReadOnlyCollection<TypeValidation> EqualsTypeValidations = new[]
        {
            new TypeValidation
            {
                Handler = ThrowIfAnyVerificationParameterTypeDoesNotEqualValueType,
            },
        };

        private static readonly IReadOnlyCollection<TypeValidation> AlwaysThrowTypeValidations = new[]
        {
            new TypeValidation
            {
                Handler = Throw,
            },
        };

        private static readonly IReadOnlyCollection<TypeValidation> ContainmentTypeValidations = new[]
        {
            new TypeValidation
            {
                Handler = ThrowIfNotOfType,
                ReferenceTypes = new[] { EnumerableType },
            },
            new TypeValidation
            {
                Handler = ThrowIfAnyVerificationParameterTypeDoesNotEqualEnumerableValueType,
            },
        };

        private static void Throw(
            Verification verification,
            VerifiableItem verifiableItem,
            TypeValidation typeValidation)
        {
            var valueTypeString = verifiableItem.ValueType.ToStringReadable();

            WorkflowExtensions.ThrowImproperUseOfFramework(Invariant($"verificationName: {verification.Name}, isElementInEnumerable: {verifiableItem.IsElementInEnumerable}, verifiableItemTypeName: {valueTypeString}"));
        }

        private static void ThrowIfValueType(
            Verification verification,
            VerifiableItem verifiableItem,
            TypeValidation typeValidation)
        {
            if (verifiableItem.ValueType.IsValueType)
            {
                ThrowSubjectUnexpectedType(verification, verifiableItem, AnyReferenceTypeName);
            }
        }

        private static void ThrowIfTypeCannotBeNull(
            Verification verification,
            VerifiableItem verifiableItem,
            TypeValidation typeValidation)
        {
            var valueType = verifiableItem.ValueType;

            if (valueType.IsValueType && (Nullable.GetUnderlyingType(valueType) == null))
            {
                ThrowSubjectUnexpectedType(verification, verifiableItem, AnyReferenceTypeName, NullableGenericTypeName);
            }
        }

        private static void ThrowIfEnumerableTypeCannotBeNull(
            Verification verification,
            VerifiableItem verifiableItem,
            TypeValidation typeValidation)
        {
            var valueType = verifiableItem.ValueType;

            var enumerableType = valueType.GetEnumerableElementType();

            if (enumerableType.IsValueType && (Nullable.GetUnderlyingType(enumerableType) == null))
            {
                // Nullable<T> is a struct, not a reference type, which is why we explicitly call it out
                // see: https://stackoverflow.com/a/3149180/356790
                ThrowSubjectUnexpectedType(verification, verifiableItem, EnumerableOfAnyReferenceTypeName, EnumerableOfNullableGenericTypeName, EnumerableWhenNotEnumerableOfAnyValueTypeName);
            }
        }

        private static void ThrowIfDictionaryTypeCannotBeNull(
            Verification verification,
            VerifiableItem verifiableItem,
            TypeValidation typeValidation)
        {
            var valueType = verifiableItem.ValueType;

            var dictionaryValueType = valueType.GetDictionaryValueType();

            if (dictionaryValueType.IsValueType && (Nullable.GetUnderlyingType(dictionaryValueType) == null))
            {
                // Nullable<T> is a struct, not a reference type, which is why we explicitly call it out
                // see: https://stackoverflow.com/a/3149180/356790
                ThrowSubjectUnexpectedType(verification, verifiableItem, DictionaryTypeName, DictionaryWithValueOfAnyReferenceTypeName, DictionaryWithValueOfNullableGenericTypeName, ReadOnlyDictionaryWithValueOfAnyReferenceTypeName, ReadOnlyDictionaryWithValueOfNullableGenericTypeName);
            }
        }

        private static void ThrowIfNotOfType(
            Verification verification,
            VerifiableItem verifiableItem,
            TypeValidation typeValidation)
        {
            var valueType = verifiableItem.ValueType;

            var validTypes = typeValidation.ReferenceTypes;

            if (!validTypes.Any(_ => valueType.IsAssignableTo(_, treatUnboundGenericAsAssignableTo: true)))
            {
                ThrowSubjectUnexpectedType(verification, verifiableItem, validTypes);
            }
        }

        private static void ThrowIfAnyVerificationParameterTypeDoesNotEqualValueType(
            Verification verification,
            VerifiableItem verifiableItem,
            TypeValidation typeValidation)
        {
            var valueType = verifiableItem.ValueType;

            foreach (var verificationParameter in verification.VerificationParameters)
            {
                if (verificationParameter.ParameterType != valueType)
                {
                    ThrowVerificationParameterUnexpectedType(verification.Name, verificationParameter.ParameterType, verificationParameter.Name, valueType);
                }
            }
        }

        private static void ThrowIfAnyVerificationParameterTypeDoesNotEqualEnumerableValueType(
            Verification verification,
            VerifiableItem verifiableItem,
            TypeValidation typeValidation)
        {
            var enumerableType = verifiableItem.ValueType.GetEnumerableElementType();

            foreach (var verificationParameter in verification.VerificationParameters)
            {
                if (verificationParameter.ParameterType != enumerableType)
                {
                    ThrowVerificationParameterUnexpectedType(verification.Name, verificationParameter.ParameterType, verificationParameter.Name, enumerableType);
                }
            }
        }

        private static void ThrowSubjectUnexpectedType(
            Verification verification,
            VerifiableItem verifiableItem,
            IReadOnlyList<Type> expectedTypes)
        {
            var expectedTypeStrings = expectedTypes.Select(_ => _.ToStringReadable()).ToArray();

            ThrowSubjectUnexpectedType(verification, verifiableItem, expectedTypeStrings);
        }

        private static void ThrowSubjectUnexpectedType(
            Verification verification,
            VerifiableItem verifiableItem,
            params string[] expectedTypes)
        {
            var valueType = verifiableItem.ValueType;

            var verificationName = verification.Name;

            var isElementInEnumerable = verifiableItem.IsElementInEnumerable;

            var expectedTypesMessage = string.Join(", ", expectedTypes.Select(_ => isElementInEnumerable ? Invariant($"IEnumerable<{_}>") : _));

            var valueTypeMessage = isElementInEnumerable ? Invariant($"IEnumerable<{valueType.ToStringReadable()}>") : valueType.ToStringReadable();

            var exceptionMessage = string.Format(CultureInfo.InvariantCulture, SubjectUnexpectedTypeErrorMessage, verificationName, valueTypeMessage, expectedTypesMessage);

            WorkflowExtensions.ThrowImproperUseOfFramework(exceptionMessage);
        }

        private static void ThrowVerificationParameterUnexpectedType(
            string verificationName,
            Type verificationParameterType,
            string verificationParameterName,
            params Type[] expectedTypes)
        {
            var expectedTypesStrings = expectedTypes.Select(_ => _.ToStringReadable()).ToArray();

            var expectedTypesMessage = string.Join(", ", expectedTypesStrings);

            var exceptionMessage = string.Format(CultureInfo.InvariantCulture, VerificationParameterUnexpectedTypeErrorMessage, verificationName, verificationParameterName, verificationParameterName, verificationParameterType.ToStringReadable(), expectedTypesMessage);

            WorkflowExtensions.ThrowImproperUseOfFramework(exceptionMessage);
        }
#pragma warning restore SA1201
    }
}
