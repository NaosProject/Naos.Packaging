// --------------------------------------------------------------------------------------------------------------------
// <copyright file="EqualityComparerHelper.cs" company="OBeautifulCode">
//   Copyright (c) OBeautifulCode 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in OBeautifulCode.Equality.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.Equality.Recipes
{
    using global::System;
    using global::System.Collections.Concurrent;
    using global::System.Collections.Generic;
    using global::System.Drawing;

    using OBeautifulCode.Type.Recipes;

    /// <summary>
    /// Helper methods related to <see cref="IEqualityComparer{T}"/>.
    /// </summary>
#if !OBeautifulCodeEqualitySolution
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [global::System.CodeDom.Compiler.GeneratedCode("OBeautifulCode.Equality.Recipes", "See package version number")]
    internal
#else
    public
#endif
    static class EqualityComparerHelper
    {
        private static readonly ConcurrentDictionary<Type, object> CachedTypeToEqualityComparerMap = new ConcurrentDictionary<Type, object>();

        private static readonly ObjectEqualityComparer ObjectEqualityComparer = new ObjectEqualityComparer();

        private static readonly ByteArrayEqualityComparer ByteArrayEqualityComparer = new ByteArrayEqualityComparer();

        private static readonly DateTimeEqualityComparer DateTimeEqualityComparer = new DateTimeEqualityComparer();

        private static readonly NullableDateTimeEqualityComparer NullableDateTimeEqualityComparer = new NullableDateTimeEqualityComparer();
        
        private static readonly ColorEqualityComparer ColorEqualityComparer = new ColorEqualityComparer();

        private static readonly NullableColorEqualityComparer NullableColorEqualityComparer = new NullableColorEqualityComparer();

        /// <summary>
        /// Gets the equality comparer to use for the specified type.
        /// </summary>
        /// <typeparam name="T">The type of the objects being compared.</typeparam>
        /// <param name="comparer">Optional comparer passed into the calling method.  Default is null, which instructs this method to determine the comparer.  If not null, then the specified comparer is returned.</param>
        /// <returns>
        /// The equality comparer to use for the specified type.
        /// </returns>
        public static IEqualityComparer<T> GetEqualityComparerToUse<T>(
            IEqualityComparer<T> comparer = null)
        {
            var type = typeof(T);

            if (comparer != null)
            {
                return comparer;
            }
            
            if (CachedTypeToEqualityComparerMap.TryGetValue(type, out object cachedResult))
            {
                return (IEqualityComparer<T>)cachedResult;
            }

            IEqualityComparer<T> result;

            if (type == typeof(object))
            {
                result = (IEqualityComparer<T>)ObjectEqualityComparer;
            }
            else if (type.IsClosedSystemDictionaryType())
            {
                // IDictionary is the only System dictionary type that doesn't implement IReadOnlyDictionary
                // which is why we have to special-case it here.
                var equalityComparerConstructorInfo = type.GetGenericTypeDefinition() == typeof(IDictionary<,>)
                    ? typeof(DictionaryEqualityComparer<,>).MakeGenericType(type.GenericTypeArguments).GetConstructor(new Type[0])
                    : typeof(ReadOnlyDictionaryEqualityComparer<,>).MakeGenericType(type.GenericTypeArguments).GetConstructor(new Type[0]);

                // ReSharper disable once PossibleNullReferenceException
                result = (IEqualityComparer<T>)equalityComparerConstructorInfo.Invoke(null);
            }
            else if (type.IsArray)
            {
                if (type == typeof(byte[]))
                {
                    result = (IEqualityComparer<T>)ByteArrayEqualityComparer;
                }
                else
                {
                    var constructorInfo = typeof(EnumerableEqualityComparer<>).MakeGenericType(type.GetElementType()).GetConstructor(new[] { typeof(EnumerableEqualityComparerStrategy) });

                    // ReSharper disable once PossibleNullReferenceException
                    result = (IEqualityComparer<T>)constructorInfo.Invoke(new object[] { EnumerableEqualityComparerStrategy.SequenceEqual });
                }
            }
            else if (type.IsClosedSystemCollectionType())
            {
                var constructorInfo = typeof(EnumerableEqualityComparer<>).MakeGenericType(type.GenericTypeArguments).GetConstructor(new[] { typeof(EnumerableEqualityComparerStrategy) });

                var enumerableEqualityComparerStrategy = type.IsClosedSystemOrderedCollectionType() ? EnumerableEqualityComparerStrategy.SequenceEqual : EnumerableEqualityComparerStrategy.UnorderedEqual;

                // ReSharper disable once PossibleNullReferenceException
                result = (IEqualityComparer<T>)constructorInfo.Invoke(new object[] { enumerableEqualityComparerStrategy });
            }
            else if (type.IsClosedSystemEnumerableType())
            {
                var constructorInfo = typeof(EnumerableEqualityComparer<>).MakeGenericType(type.GenericTypeArguments).GetConstructor(new[] { typeof(EnumerableEqualityComparerStrategy) });

                // ReSharper disable once PossibleNullReferenceException
                result = (IEqualityComparer<T>)constructorInfo.Invoke(new object[] { EnumerableEqualityComparerStrategy.UnorderedEqual });
            }
            else if (type == typeof(DateTime))
            {
                result = (IEqualityComparer<T>)DateTimeEqualityComparer;
            }
            else if (type == typeof(DateTime?))
            {
                result = (IEqualityComparer<T>)NullableDateTimeEqualityComparer;
            }
            else if (type == typeof(Color))
            {
                result = (IEqualityComparer<T>)ColorEqualityComparer;
            }
            else if (type == typeof(Color?))
            {
                result = (IEqualityComparer<T>)NullableColorEqualityComparer;
            }
            else
            {
                result = EqualityComparer<T>.Default;
            }

            CachedTypeToEqualityComparerMap.TryAdd(type, result);

            return result;
        }
    }
}