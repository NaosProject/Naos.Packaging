// --------------------------------------------------------------------------------------------------------------------
// <copyright file="TypeExtensions.cs" company="OBeautifulCode">
//   Copyright (c) OBeautifulCode 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in OBeautifulCode.Type.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.Type.Recipes
{
    using System;
    using System.CodeDom;
    using System.CodeDom.Compiler;
    using System.Collections;
    using System.Collections.Concurrent;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Globalization;
    using System.Linq;
    using System.Reflection;
    using System.Runtime.CompilerServices;
    using System.Text.RegularExpressions;

    using static System.FormattableString;

    /// <summary>
    /// Extension methods on type <see cref="Type"/>.
    /// </summary>
#if !OBeautifulCodeTypeRecipesProject
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [System.CodeDom.Compiler.GeneratedCode("OBeautifulCode.Type.Recipes", "See package version number")]
    internal
#else
    public
#endif
    static class TypeExtensions
    {
        private static readonly HashSet<Type> CollectionTypes =
            new HashSet<Type>(new[]
            {
                typeof(Collection<>),
                typeof(ICollection<>),
                typeof(ReadOnlyCollection<>),
                typeof(IReadOnlyCollection<>),
                typeof(List<>),
                typeof(IList<>),
                typeof(IReadOnlyList<>),
            });

        private static readonly HashSet<Type> OrderedCollectionTypes =
            new HashSet<Type>(new[]
            {
                typeof(Collection<>),
                typeof(ReadOnlyCollection<>),
                typeof(List<>),
                typeof(IList<>),
                typeof(IReadOnlyList<>),
            });

        private static readonly HashSet<Type> UnorderedCollectionTypes =
            new HashSet<Type>(new[]
            {
                typeof(ICollection<>),
                typeof(IReadOnlyCollection<>),
            });

        private static readonly HashSet<Type> DictionaryTypes =
            new HashSet<Type>(new[]
            {
                typeof(Dictionary<,>),
                typeof(IDictionary<,>),
                typeof(ReadOnlyDictionary<,>),
                typeof(IReadOnlyDictionary<,>),
                typeof(ConcurrentDictionary<,>),
            });

        private static readonly Type ComparableType = typeof(IComparable);

        private static readonly Type UnboundGenericComparableType = typeof(IComparable<>);

        private static readonly Regex GenericBracketsRegex = new Regex("<.*>", RegexOptions.Compiled);

        private static readonly CodeDomProvider CodeDomProvider = CodeDomProvider.CreateProvider("CSharp");

        private static readonly Dictionary<Type, string> Aliases = new Dictionary<Type, string>
        {
            { typeof(byte), "byte" },
            { typeof(sbyte), "sbyte" },
            { typeof(short), "short" },
            { typeof(ushort), "ushort" },
            { typeof(int), "int" },
            { typeof(uint), "uint" },
            { typeof(long), "long" },
            { typeof(ulong), "ulong" },
            { typeof(float), "float" },
            { typeof(double), "double" },
            { typeof(decimal), "decimal" },
            { typeof(object), "object" },
            { typeof(bool), "bool" },
            { typeof(char), "char" },
            { typeof(string), "string" },
            { typeof(void), "void" },
        };

        private static readonly Type ObjectType = typeof(object);

        private static readonly Type EnumerableType = typeof(IEnumerable);

        private static readonly Type DictionaryType = typeof(IDictionary);

        private static readonly Type UnboundGenericEnumerableType = typeof(IEnumerable<>);

        private static readonly Type UnboundGenericDictionaryType = typeof(IDictionary<,>);

        private static readonly Type UnboundGenericReadOnlyDictionaryType = typeof(IReadOnlyDictionary<,>);

        /// <summary>
        /// Gets the type of the elements of a specified enumerable type.
        /// </summary>
        /// <param name="type">The enumerable type.</param>
        /// <returns>
        /// The type of the elements of the specified enumerable type.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="type"/> is not assignable to <see cref="EnumerableType"/>.</exception>
        public static Type GetEnumerableElementType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (!type.IsAssignableTo(EnumerableType))
            {
                throw new ArgumentException(Invariant($"Specified type is not assignable to IEnumerable: {type.Name}."));
            }

            var result = type.GetEnumerableElementTypeInternal();

            return result;
        }

        /// <summary>
        /// Gets the type of the values of a specified dictionary type.
        /// </summary>
        /// <param name="type">The dictionary type.</param>
        /// <returns>
        /// The type of the values of the specified dictionary type.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="type"/> cannot be assigned to <see cref="UnboundGenericReadOnlyDictionaryType"/>, <see cref="UnboundGenericDictionaryType"/>, or <see cref="DictionaryType"/>.</exception>
        public static Type GetDictionaryValueType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if ((!type.IsAssignableTo(UnboundGenericReadOnlyDictionaryType, treatUnboundGenericAsAssignableTo: true)) &&
                (!type.IsAssignableTo(UnboundGenericDictionaryType, treatUnboundGenericAsAssignableTo: true)) &&
                (!type.IsAssignableTo(DictionaryType, treatUnboundGenericAsAssignableTo: true)))
            {
                throw new ArgumentException(Invariant($"Specified type is cannot be assigned to either IReadOnlyDictionary<T,K>, IDictionary<T,K>, or IDictionary: {type.Name}."));
            }

            var result = type.GetDictionaryValueTypeInternal();

            return result;
        }

        /// <summary>
        /// Determines if a type is an anonymous type.
        /// </summary>
        /// <param name="type">Type to check.</param>
        /// <returns>A value indicating whether or not the type provided is anonymous.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool IsAnonymous(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            var result = Attribute.IsDefined(type, typeof(CompilerGeneratedAttribute), false)
                             && type.Namespace == null
                             && type.IsGenericType
                             && type.Name.Contains("AnonymousType")
                             && (type.Name.StartsWith("<>", StringComparison.Ordinal) || type.Name.StartsWith("VB$", StringComparison.Ordinal))
                             && type.Attributes.HasFlag(TypeAttributes.NotPublic);

            return result;
        }

        /// <summary>
        /// Determines if a type is an anonymous type using a faster, but potentially
        /// less accurate heuristic than <see cref="IsAnonymous(Type)"/>.
        /// </summary>
        /// <param name="type">Type to check.</param>
        /// <returns>A value indicating whether or not the type provided is anonymous.</returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool IsAnonymousFastCheck(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            var result = type.Namespace == null;

            return result;
        }

        /// <summary>
        /// Determines if a type if assignable to another type.
        /// </summary>
        /// <remarks>
        /// Adapted from: <a href="https://stackoverflow.com/questions/74616/how-to-detect-if-type-is-another-generic-type/1075059#1075059" />.
        /// </remarks>
        /// <param name="type">The current type.</param>
        /// <param name="otherType">The type to check for ability to assign to.</param>
        /// <param name="treatUnboundGenericAsAssignableTo">Treats an unbound generic as a type that can be assigned to (e.g. IsAssignableTo(List&lt;int&gt;, List&lt;&gt;)).</param>
        /// <returns>
        /// true if <paramref name="type"/> can be assigned to <paramref name="otherType"/>; otherwise false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="otherType"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="type"/>.<see cref="Type.IsGenericTypeDefinition"/> is true.</exception>
        public static bool IsAssignableTo(
            this Type type,
            Type otherType,
            bool treatUnboundGenericAsAssignableTo = false)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (otherType == null)
            {
                throw new ArgumentNullException(nameof(otherType));
            }

            if (type.IsGenericTypeDefinition)
            {
                throw new ArgumentException(Invariant($"{nameof(type)}.{nameof(Type.IsGenericTypeDefinition)} is {true}"));
            }

            // type is equal to the other type
            if (type == otherType)
            {
                return true;
            }

            // type is assignable to the other type
            if (otherType.IsAssignableFrom(type))
            {
                return true;
            }

            // type is generic and other type is an unbounded generic type
            if (treatUnboundGenericAsAssignableTo && otherType.IsGenericTypeDefinition)
            {
                // type's unbounded generic version is the other type
                if (type.IsGenericType && type.GetGenericTypeDefinition() == otherType)
                {
                    return true;
                }

                // type implements an interface who's unbounded generic version is the other type
                if (type.GetInterfaces().Any(_ => _.IsGenericType && (_.GetGenericTypeDefinition() == otherType)))
                {
                    return true;
                }

                var baseType = type.BaseType;
                if (baseType == null)
                {
                    return false;
                }

                // ReSharper disable once ConditionIsAlwaysTrueOrFalse
                var result = baseType.IsAssignableTo(otherType, treatUnboundGenericAsAssignableTo);
                return result;
            }

            return false;
        }

        /// <summary>
        /// Determines if the specified type is assignable to null.
        /// </summary>
        /// <remarks>Adapted from: <a href="https://stackoverflow.com/a/1770232/356790" />.</remarks>
        /// <param name="type">The type.</param>
        /// <returns>
        /// true if the specified type is assignable to null, otherwise false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool IsAssignableToNull(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            var result = (!type.IsValueType) || type.IsNullableType();

            return result;
        }

        /// <summary>
        /// Determines if the specified type is comparable.
        /// </summary>
        /// <typeparam name="T">The type.</typeparam>
        /// <returns>
        /// true if the type is comparable, otherwise false.
        /// </returns>
        public static bool IsComparableType<T>()
        {
            var type = typeof(T);

            var result = IsComparableType(type);

            return result;
        }

        /// <summary>
        /// Determines if the specified type is comparable.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>
        /// true if the type is comparable, otherwise false.
        /// </returns>
        public static bool IsComparableType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            // Previously, we called Comparer<T>.Default and checked whether that was equal to ObjectComparer<T>.
            // If so, we considered the type to be NOT comparable.  Comparer<T>.Default checks, among other things,
            // whether T is IComparable<T>.  Unfortunately, types like Enum don't implement IComparable<T>,
            // but are IComparable.  So for enums, Comparer<T>.Default returns ObjectComparer<T>.  It turns out,
            // ObjectComparer<T> doesn't just check for reference equality.  Among other things, it checks whether
            // the type is IComparable.  So we combined the approach taken by Comparer<T>.Default and ObjectComparer<T>
            // into the follow...
            bool result;

            var genericComparableType = UnboundGenericComparableType.MakeGenericType(type);

            if (type.IsAssignableTo(genericComparableType))
            {
                result = true;
            }
            else if (type.IsAssignableTo(ComparableType))
            {
                result = true;
            }
            else if (type.IsNullableType())
            {
                var underlyingType = type.GetGenericArguments()[0];

                result = IsComparableType(underlyingType);
            }
            else
            {
                result = false;
            }

            return result;
        }

        /// <summary>
        /// Determines if the specified type is a class type, that's not anonymous, and is closed.
        /// </summary>
        /// <remarks>
        /// This is basically asking, "Is this a class type that can be constructed/new-ed up?"
        /// </remarks>
        /// <param name="type">The type.</param>
        /// <returns>
        /// true if the specified type is a class type, non-anonymous, and closed.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool IsNonAnonymousClosedClassType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            var result =
                type.IsClass &&
                (!type.IsAnonymous()) &&
                (!type.IsGenericTypeDefinition); // can't do an IsAssignableTo check on generic type definitions

            return result;
        }

        /// <summary>
        /// Determines if the specified type is <see cref="Nullable{T}"/>.
        /// </summary>
        /// <remarks>Adapted from: <a href="https://stackoverflow.com/a/41281601/356790" />.</remarks>
        /// <param name="type">The type.</param>
        /// <returns>
        /// true if the specified type is <see cref="Nullable{T}"/>, otherwise false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool IsNullableType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            var result = Nullable.GetUnderlyingType(type) != null;

            return result;
        }

        /// <summary>
        /// Determines if the specified type is one of the following <see cref="System"/> collection types: <see cref="CollectionTypes"/>.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>
        /// true if the specified type is a <see cref="System"/> collection type; otherwise false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool IsSystemCollectionType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (!type.IsGenericType)
            {
                return false;
            }

            var genericType = type.GetGenericTypeDefinition();

            var result = CollectionTypes.Contains(genericType);

            return result;
        }

        /// <summary>
        /// Determines if the specified type is one of the following <see cref="System"/> dictionary types: <see cref="DictionaryTypes"/>.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>
        /// true if the specified type is a <see cref="System"/> dictionary type; otherwise false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool IsSystemDictionaryType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (!type.IsGenericType)
            {
                return false;
            }

            var genericType = type.GetGenericTypeDefinition();

            var result = DictionaryTypes.Contains(genericType);

            return result;
        }

        /// <summary>
        /// Determines if the specified type is one of the following <see cref="System"/>
        /// ordered collection types: <see cref="OrderedCollectionTypes"/>.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>
        /// true if the specified type is an ordered <see cref="System"/> collection type; otherwise false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool IsSystemOrderedCollectionType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (!type.IsGenericType)
            {
                return false;
            }

            var genericType = type.GetGenericTypeDefinition();

            var result = OrderedCollectionTypes.Contains(genericType);

            return result;
        }

        /// <summary>
        /// Determines if the specified type is one of the following <see cref="System"/>
        /// unordered collection types: <see cref="UnorderedCollectionTypes"/>.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>
        /// true if the specified type is an unordered <see cref="System"/> collection type; otherwise false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static bool IsSystemUnorderedCollectionType(
            this Type type)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            if (!type.IsGenericType)
            {
                return false;
            }

            var genericType = type.GetGenericTypeDefinition();

            var result = UnorderedCollectionTypes.Contains(genericType);

            return result;
        }

        /// <summary>
        /// Gets a compilable, readability-optimized string representation of the specified type.
        /// </summary>
        /// <remarks>
        /// Adapted from: <a href="https://stackoverflow.com/a/6402967/356790" />.
        /// Adapted from: <a href="https://stackoverflow.com/questions/1362884/is-there-a-way-to-get-a-types-alias-through-reflection" />.
        /// Helpful breakdown of generics: <a href="https://docs.microsoft.com/en-us/dotnet/api/system.type.isgenerictype" />.
        /// </remarks>
        /// <param name="type">The type.</param>
        /// <param name="throwIfNoCompilableStringExists">Optional value indicating whether to throw a <see cref="NotSupportedException"/> if there's no compilable representation of the specified type.</param>
        /// <returns>
        /// A compilable, readability-optimized string representation of the specified type
        /// OR
        /// null if there is no compilable representation and <paramref name="throwIfNoCompilableStringExists"/> is true.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        /// <exception cref="NotSupportedException"><paramref name="throwIfNoCompilableStringExists"/> is true and <paramref name="type"/> is a generic open constructed type, which is not supported.</exception>
        /// <exception cref="NotSupportedException"><paramref name="throwIfNoCompilableStringExists"/> is true and <paramref name="type"/> is a generic parameter.</exception>
        public static string ToStringCompilable(
            this Type type,
            bool throwIfNoCompilableStringExists = false)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            string result;

            if (type.IsAnonymous())
            {
                if (throwIfNoCompilableStringExists)
                {
                    throw new NotSupportedException("Anonymous types are not supported.");
                }
                else
                {
                    result = null;
                }
            }
            else if (type.IsGenericParameter)
            {
                if (throwIfNoCompilableStringExists)
                {
                    // note that IsGenericParameter and ContainsGenericParameters will return true for generic parameters,
                    // hence we order the IsGenericParameter check first.
                    throw new NotSupportedException("Generic parameters not supported.");
                }
                else
                {
                    result = null;
                }
            }
            else
            {
                if (Aliases.ContainsKey(type))
                {
                    result = Aliases[type];
                }
                else if (type.IsNullableType())
                {
                    result = Nullable.GetUnderlyingType(type).ToStringCompilable() + "?";
                }
                else if (type.IsArray)
                {
                    result = type.GetElementType().ToStringCompilable() + "[]";
                }
                else
                {
                    result = CodeDomProvider.GetTypeOutput(new CodeTypeReference(type.FullName?.Replace(type.Namespace + ".", string.Empty)));

                    if (type.IsGenericType)
                    {
                        if (type.IsGenericTypeDefinition)
                        {
                            result = result.Replace(" ", string.Empty);
                        }
                        else if (type.ContainsGenericParameters)
                        {
                            if (throwIfNoCompilableStringExists)
                            {
                                throw new NotSupportedException("Generic open constructed types are not supported.");
                            }
                            else
                            {
                                result = null;
                            }
                        }
                        else
                        {
                            var genericParameters = type.GetGenericArguments().Select(_ => _.ToStringCompilable()).ToArray();

                            result = GenericBracketsRegex.Replace(result, "<" + string.Join(", ", genericParameters) + ">");
                        }
                    }
                }
            }

            return result;
        }

        /// <summary>
        /// Gets a readability-optimized string representation of the specified type.
        /// </summary>
        /// <remarks>
        /// Adapted from: <a href="https://stackoverflow.com/a/6402967/356790" />.
        /// Adapted from: <a href="https://stackoverflow.com/questions/1362884/is-there-a-way-to-get-a-types-alias-through-reflection" />.
        /// Helpful breakdown of generics: <a href="https://docs.microsoft.com/en-us/dotnet/api/system.type.isgenerictype" />.
        /// </remarks>
        /// <param name="type">The type.</param>
        /// <param name="options">The options to use when generating the string representation.</param>
        /// <returns>
        /// A readability-optimized string representation of the specified type.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type"/> is null.</exception>
        public static string ToStringReadable(
            this Type type,
            ToStringReadableOptions options = ToStringReadableOptions.None)
        {
            if (type == null)
            {
                throw new ArgumentNullException(nameof(type));
            }

            var assemblyDetailsTypes = new List<Type>();

            var result = type.ToStringReadableInternal(options, assemblyDetailsTypes);

            var includeAssemblyDetails = options.HasFlag(ToStringReadableOptions.IncludeAssemblyDetails);

            if (includeAssemblyDetails && assemblyDetailsTypes.Any())
            {
                result = result + " || " + string.Join(" | ", assemblyDetailsTypes.Select(_ => _.ToAssemblyDetails()).ToArray());
            }

            return result;
        }

        private static Type GetEnumerableElementTypeInternal(
            this Type type)
        {
            Type result;
            if (type.IsArray)
            {
                // type is array, shortcut
                result = type.GetElementType();
            }
            else if (type.IsGenericType && (type.GetGenericTypeDefinition() == UnboundGenericEnumerableType))
            {
                // type is IEnumerable<T>
                result = type.GetGenericArguments()[0];
            }
            else
            {
                // type implements IEnumerable<T> or is a subclass (sub-sub-class, ...)
                // of a type that implements IEnumerable<T>
                // note that we are grabbing the first implementation.  it is possible, but
                // highly unlikely, for a type to have multiple implementations of IEnumerable<T>
                result = type
                    .GetInterfaces()
                    .Where(_ => _.IsGenericType && (_.GetGenericTypeDefinition() == UnboundGenericEnumerableType))
                    .Select(_ => _.GenericTypeArguments[0])
                    .FirstOrDefault();

                if (result == null)
                {
                    var baseType = type.BaseType;
                    result = baseType == null ? ObjectType : GetEnumerableElementTypeInternal(baseType);
                }
            }

            return result;
        }

        private static Type GetDictionaryValueTypeInternal(
            this Type type)
        {
            Type result;

            if (type.IsGenericType && (type.GetGenericTypeDefinition() == UnboundGenericDictionaryType))
            {
                // type is IDictionary<T,K>
                result = type.GetGenericArguments()[1];
            }
            else if (type.IsGenericType && (type.GetGenericTypeDefinition() == UnboundGenericReadOnlyDictionaryType))
            {
                // type is IReadOnlyDictionary<T,K>
                result = type.GetGenericArguments()[1];
            }
            else
            {
                // type implements IDictionary<T,K>/IReadOnlyDictionary<T,K> or is a subclass (sub-sub-class, ...)
                // of a type that implements those types
                // note that we are grabbing the first implementation.  it is possible, but
                // highly unlikely, for a type to have multiple implementations of IDictionary<T,K>
                result = type
                    .GetInterfaces()
                    .Where(_ => _.IsGenericType && ((_.GetGenericTypeDefinition() == UnboundGenericDictionaryType) || (_.GetGenericTypeDefinition() == UnboundGenericReadOnlyDictionaryType)))
                    .Select(_ => _.GenericTypeArguments[1])
                    .FirstOrDefault();

                if (result == null)
                {
                    var baseType = type.BaseType;
                    result = baseType == null ? ObjectType : GetDictionaryValueTypeInternal(baseType);
                }
            }

            return result;
        }

        private static string ToStringReadableInternal(
            this Type type,
            ToStringReadableOptions options,
            IList<Type> assemblyDetailsTypes = null)
        {
            string result;

            if (type.IsGenericParameter)
            {
                result = type.Name;
            }
            else if (Aliases.ContainsKey(type))
            {
                assemblyDetailsTypes?.Add(type);

                result = Aliases[type];
            }
            else if (type.IsNullableType())
            {
                result = Nullable.GetUnderlyingType(type).ToStringReadableInternal(options, assemblyDetailsTypes) + "?";
            }
            else if (type.IsArray)
            {
                result = type.GetElementType().ToStringReadableInternal(options, assemblyDetailsTypes) + "[]";
            }
            else
            {
                assemblyDetailsTypes?.Add(type);

                result = CodeDomProvider.GetTypeOutput(new CodeTypeReference(type.FullName?.Replace(type.Namespace + ".", string.Empty) ?? type.Name));

                var includeNamespace = options.HasFlag(ToStringReadableOptions.IncludeNamespace);
                if (includeNamespace && (type.Namespace != null))
                {
                    result = type.Namespace + "." + result;
                }

                if (type.IsGenericType)
                {
                    var isAnonymous = type.IsAnonymous();

                    if (isAnonymous)
                    {
                        result = result.Replace("<>f__", string.Empty);
                    }

                    string[] genericParameters;
                    if (isAnonymous && type.IsGenericTypeDefinition)
                    {
                        genericParameters = type.GetGenericArguments().Select((_, i) => "T" + (i + 1).ToString(CultureInfo.InvariantCulture)).ToArray();
                    }
                    else
                    {
                        genericParameters = type.GetGenericArguments().Select(_ => _.ToStringReadableInternal(options, assemblyDetailsTypes)).ToArray();
                    }

                    result = GenericBracketsRegex.Replace(result, "<" + string.Join(", ", genericParameters) + ">");
                }
            }

            return result;
        }

        private static string ToAssemblyDetails(
            this Type type)
        {
            if (type.IsGenericType)
            {
                type = type.GetGenericTypeDefinition();
            }

            var fullyQualifiedTypeName = type.ToStringReadableInternal(ToStringReadableOptions.IncludeNamespace);

            var assemblyName = type.Assembly.GetName();

            var result = fullyQualifiedTypeName + " => " + assemblyName.Name + " (" + assemblyName.Version + ")";

            return result;
        }
    }
}
