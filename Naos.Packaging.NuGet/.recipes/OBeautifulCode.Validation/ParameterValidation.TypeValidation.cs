// --------------------------------------------------------------------------------------------------------------------
// <copyright file="ParameterValidation.TypeValidation.cs" company="OBeautifulCode">
//   Copyright (c) OBeautifulCode 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in OBeautifulCode.Validation source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.Validation.Recipes
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;

    using static System.FormattableString;

    /// <summary>
    /// Contains all validations that can be applied to a <see cref="Parameter"/>.
    /// </summary>
#if !OBeautifulCodeValidationRecipesProject
    internal
#else
    public
#endif
        static partial class ParameterValidation
    {
#pragma warning disable SA1201
        private delegate void TypeValidationHandler(
            Validation validation,
            TypeValidation typeValidation);

        private static readonly Type EnumerableType = typeof(IEnumerable);

        private static readonly Type UnboundGenericEnumerableType = typeof(IEnumerable<>);

        private static readonly Type ComparableType = typeof(IComparable);

        private static readonly Type UnboundGenericComparableType = typeof(IComparable<>);

        private static readonly Type ObjectType = typeof(object);

        private static readonly Type BoolType = typeof(bool);

        private static readonly Type NullableBoolType = typeof(bool?);

        private static readonly Type StringType = typeof(string);

        private static readonly Type GuidType = typeof(Guid);

        private static readonly Type NullableGuidType = typeof(Guid?);

        private static readonly Type DictionaryType = typeof(IDictionary);

        private static readonly Type UnboundGenericDictionaryType = typeof(IDictionary<,>);

        private static readonly Type UnboundGenericReadOnlyDictionaryType = typeof(IReadOnlyDictionary<,>);

        private static readonly Type NullableType = typeof(Nullable<>);

        private static readonly IReadOnlyCollection<TypeValidation> MustBeNullableTypeValidations = new[]
        {
            new TypeValidation
            {
                TypeValidationHandler = ThrowIfTypeCannotBeNull,
            },
        };

        private static readonly IReadOnlyCollection<TypeValidation> MustBeBooleanTypeValidations = new[]
        {
            new TypeValidation
            {
                TypeValidationHandler = ThrowIfNotOfType,
                ReferenceTypes = new[] { BoolType, NullableBoolType },
            },
        };

        private static readonly IReadOnlyCollection<TypeValidation> MustBeStringTypeValidations = new[]
        {
            new TypeValidation
            {
                TypeValidationHandler = ThrowIfNotOfType,
                ReferenceTypes = new[] { StringType },
            },
        };

        private static readonly IReadOnlyCollection<TypeValidation> MustBeGuidTypeValidations = new[]
        {
            new TypeValidation
            {
                TypeValidationHandler = ThrowIfNotOfType,
                ReferenceTypes = new[] { GuidType, NullableGuidType },
            },
        };

        private static readonly IReadOnlyCollection<TypeValidation> MustBeEnumerableTypeValidations = new[]
        {
            new TypeValidation
            {
                TypeValidationHandler = ThrowIfNotOfType,
                ReferenceTypes = new[] { EnumerableType },
            },
        };

        private static readonly IReadOnlyCollection<TypeValidation> MustBeEnumerableOfNullableTypeValidations = new[]
        {
            new TypeValidation
            {
                TypeValidationHandler = ThrowIfNotOfType,
                ReferenceTypes = new[] { EnumerableType },
            },
            new TypeValidation
            {
                TypeValidationHandler = ThrowIfEnumerableTypeCannotBeNull,
            },
        };

        private static readonly IReadOnlyCollection<TypeValidation> MustBeDictionaryTypeValidations = new[]
        {
            new TypeValidation
            {
                TypeValidationHandler = ThrowIfNotOfType,
                ReferenceTypes = new[] { DictionaryType, UnboundGenericDictionaryType, UnboundGenericReadOnlyDictionaryType },
            },
        };

        private static readonly IReadOnlyCollection<TypeValidation> MustBeDictionaryOfNullableTypeValidations = new[]
        {
            new TypeValidation
            {
                TypeValidationHandler = ThrowIfNotOfType,
                ReferenceTypes = new[] { DictionaryType, UnboundGenericDictionaryType, UnboundGenericReadOnlyDictionaryType },
            },
            new TypeValidation
            {
                TypeValidationHandler = ThrowIfDictionaryTypeCannotBeNull,
            },
        };

        private static readonly IReadOnlyCollection<TypeValidation> InequalityTypeValidations = new[]
        {
            new TypeValidation
            {
                TypeValidationHandler = ThrowIfNotOfType,
                ReferenceTypes = new[] { ComparableType, UnboundGenericComparableType, NullableType },
            },
            new TypeValidation
            {
                TypeValidationHandler = ThrowIfAnyValidationParameterTypeDoesNotEqualValueType,
            },
        };

        private static readonly IReadOnlyCollection<TypeValidation> EqualsTypeValidations = new[]
        {
            new TypeValidation
            {
                TypeValidationHandler = ThrowIfAnyValidationParameterTypeDoesNotEqualValueType,
            },
        };

        private static readonly IReadOnlyCollection<TypeValidation> AlwaysThrowTypeValidations = new[]
        {
            new TypeValidation
            {
                TypeValidationHandler = Throw,
            },
        };

        private static readonly IReadOnlyCollection<TypeValidation> ContainmentTypeValidations = new[]
        {
            new TypeValidation
            {
                TypeValidationHandler = ThrowIfNotOfType,
                ReferenceTypes = new[] { EnumerableType },
            },
            new TypeValidation
            {
                TypeValidationHandler = ThrowIfAnyValidationParameterTypeDoesNotEqualEnumerableValueType,
            },
        };

        // ReSharper disable once UnusedParameter.Local
        private static void Throw(
            Validation validation,
            TypeValidation typeValidation)
        {
            var parameterValueTypeName = validation.ValueType.GetFriendlyTypeName();
            throw new InvalidCastException(Invariant($"validationName: {validation.ValidationName}, isElementInEnumerable: {validation.IsElementInEnumerable}, parameterValueTypeName: {parameterValueTypeName}"));
        }

        private static void ThrowIfTypeCannotBeNull(
            Validation validation,
            TypeValidation typeValidation)
        {
            var valueType = validation.ValueType;

            if (valueType.IsValueType && (Nullable.GetUnderlyingType(valueType) == null))
            {
                ThrowParameterUnexpectedType(validation, AnyReferenceTypeName, NullableGenericTypeName);
            }
        }

        private static void ThrowIfEnumerableTypeCannotBeNull(
            Validation validation,
            TypeValidation typeValidation)
        {
            var valueType = validation.ValueType;

            var enumerableType = GetEnumerableGenericType(valueType);

            if (enumerableType.IsValueType && (Nullable.GetUnderlyingType(enumerableType) == null))
            {
                // Nullable<T> is a struct, not a reference type, which is why we explicitly call it out
                // see: https://stackoverflow.com/a/3149180/356790
                ThrowParameterUnexpectedType(validation, EnumerableOfAnyReferenceTypeName, EnumerableOfNullableGenericTypeName, EnumerableWhenNotEnumerableOfAnyValueTypeName);
            }
        }

        private static void ThrowIfDictionaryTypeCannotBeNull(
            Validation validation,
            TypeValidation typeValidation)
        {
            var valueType = validation.ValueType;

            var dictionaryValueType = GetDictionaryGenericValueType(valueType);

            if (dictionaryValueType.IsValueType && (Nullable.GetUnderlyingType(dictionaryValueType) == null))
            {
                // Nullable<T> is a struct, not a reference type, which is why we explicitly call it out
                // see: https://stackoverflow.com/a/3149180/356790
                ThrowParameterUnexpectedType(validation, DictionaryTypeName, DictionaryWithValueOfAnyReferenceTypeName, DictionaryWithValueOfNullableGenericTypeName, ReadOnlyDictionaryWithValueOfAnyReferenceTypeName, ReadOnlyDictionaryWithValueOfNullableGenericTypeName);
            }
        }

        private static void ThrowIfNotOfType(
            Validation validation,
            TypeValidation typeValidation)
        {
            var valueType = validation.ValueType;
            var validTypes = typeValidation.ReferenceTypes;

            if (!validTypes.Any(_ => valueType.IsAssignableTo(_, treatUnboundGenericAsAssignableTo: true)))
            {
                ThrowParameterUnexpectedType(validation, validTypes);
            }
        }

        private static void ThrowIfAnyValidationParameterTypeDoesNotEqualValueType(
            Validation validation,
            TypeValidation typeValidation)
        {
            var valueType = validation.ValueType;

            foreach (var validationParameter in validation.ValidationParameters)
            {
                if (validationParameter.ValueType != valueType)
                {
                    ThrowValidationParameterUnexpectedType(validation.ValidationName, validationParameter.ValueType, validationParameter.Name, valueType);
                }
            }
        }

        private static void ThrowIfAnyValidationParameterTypeDoesNotEqualEnumerableValueType(
            Validation validation,
            TypeValidation typeValidation)
        {
            var enumerableType = GetEnumerableGenericType(validation.ValueType);

            foreach (var validationParameter in validation.ValidationParameters)
            {
                if (validationParameter.ValueType != enumerableType)
                {
                    ThrowValidationParameterUnexpectedType(validation.ValidationName, validationParameter.ValueType, validationParameter.Name, enumerableType);
                }
            }
        }

        private static void ThrowParameterUnexpectedType(
            Validation validation,
            params Type[] expectedTypes)
        {
            var expectedTypeStrings = expectedTypes.Select(_ => _.GetFriendlyTypeName()).ToArray();
            ThrowParameterUnexpectedType(validation, expectedTypeStrings);
        }

        private static void ThrowParameterUnexpectedType(
            Validation validation,
            params string[] expectedTypes)
        {
            var valueType = validation.ValueType;
            var validationName = validation.ValidationName;
            var isElementInEnumerable = validation.IsElementInEnumerable;

            var expectedTypesMessage = string.Join(", ", expectedTypes.Select(_ => isElementInEnumerable ? Invariant($"IEnumerable<{_}>") : _));
            var valueTypeMessage = isElementInEnumerable ? Invariant($"IEnumerable<{valueType.GetFriendlyTypeName()}>") : valueType.GetFriendlyTypeName();
            var exceptionMessage = Invariant($"Called {validationName}() on a parameter of type {valueTypeMessage}, which is not one of the following expected type(s): {expectedTypesMessage}.");
            throw new InvalidCastException(exceptionMessage);
        }

        private static void ThrowValidationParameterUnexpectedType(
            string validationName,
            Type validationParameterType,
            string validationParameterName,
            params Type[] expectedTypes)
        {
            var expectedTypesStrings = expectedTypes.Select(_ => _.GetFriendlyTypeName()).ToArray();
            var expectedTypesMessage = string.Join(", ", expectedTypesStrings);
            var exceptionMessage = Invariant($"Called {validationName}({validationParameterName}:) where '{validationParameterName}' is of type {validationParameterType.GetFriendlyTypeName()}, which is not one of the following expected type(s): {expectedTypesMessage}.");
            throw new InvalidCastException(exceptionMessage);
        }

        private class TypeValidation
        {
            public TypeValidationHandler TypeValidationHandler { get; set; }

            public Type[] ReferenceTypes { get; set; }
        }

#pragma warning restore SA1201
    }
}
